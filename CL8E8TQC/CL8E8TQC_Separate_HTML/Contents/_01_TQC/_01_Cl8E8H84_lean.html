<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lean Notebook Viewer</title>
  <script>
    // MathJax config ‚Äî from MATHJAX_CONFIG in renderer.js (single source of truth).
    MathJax = {"tex":{"inlineMath":[["$","$"]],"displayMath":[["$$","$$"]],"processEscapes":true},"options":{"skipHtmlTags":["script","noscript","style","textarea","pre","code"],"menuOptions":{"settings":{"enrich":false,"collapsible":false,"speech":false,"braille":false,"assistiveMml":false}}},"startup":{"typeset":false}};
  </script>
  <script async src="../../_libs/tex-svg.js"></script>
  <script src="../../_libs/marked.min.js"></script>
  <script src="../../_libs/mermaid.min.js"></script>
  <script src="../../_libs/viz-standalone.js" async></script>
  <style>
    /* Injected from style.css by htmlExporter.ts ‚Äî do NOT edit here. Edit style.css instead. */
    /* style.css ‚Äî LeanNotebook VSCode Extension
   Identical CSS for both the static HTML viewer and the Extension WebView.
   Overrides VSCode user themes to prioritize the Lean brand.
*/

@import url('https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,wght@0,400;0,600;1,400&family=Fira+Code:wght@400;500&family=Inter:wght@300;400;500;600&display=swap');

:root {
  /* Lean brand: white + blue */
  --bg: #f4f7fb;
  --surface: #ffffff;
  --surface-alt: #eef2f8;
  --border: #d0daea;
  --border-soft: #e4eaf4;
  --text: #1a2233;
  --text-muted: #4a5a78;
  --text-dim: #8a9ab8;
  /* Lean blue palette */
  --blue: #2563eb;
  --blue-light: #3b82f6;
  --blue-pale: #dbeafe;
  --blue-dim: #93c5fd;
  --blue-dark: #1d4ed8;
  /* syntax */
  --hl-keyword: #1d4ed8;
  --hl-tactic: #7c3aed;
  --hl-type: #0369a1;
  --hl-string: #15803d;
  --hl-number: #b45309;
  --hl-comment: #94a3b8;
  --hl-op: #475569;
  /* code bg */
  --code-bg: #f0f4ff;
  --radius: 7px;
  --font-prose: 'Source Serif 4', Georgia, serif;
  --font-code: 'Fira Code', 'Courier New', monospace;
  --font-ui: 'Inter', system-ui, sans-serif;
  --shadow-sm: 0 1px 3px rgba(37, 99, 235, .08), 0 1px 2px rgba(0, 0, 0, .04);
  --shadow-md: 0 4px 12px rgba(37, 99, 235, .10), 0 1px 4px rgba(0, 0, 0, .05);
}

*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html {
  scroll-behavior: smooth;
  width: 100%;
  height: 100%;
}

body {
  background: var(--bg);
  color: var(--text);
  font-family: var(--font-ui);
  font-size: 16px;
  line-height: 1.6;
  min-height: 100vh;
  width: 100%;
}

/* ================================================================
   Overall Layout: Sidebar + Main Content
   Extension WebView: #layout
   HTML Export: #app (topbar + sidebar + notebook)
   ================================================================ */

/* --- Common root grid (#app) --- */
#app {
  display: grid;
  grid-template-columns: 260px 1fr;
  grid-template-rows: auto 1fr;
  min-height: 100vh;
}

#topbar {
  grid-column: 1 / -1;
  background: var(--surface);
  border-bottom: 1px solid var(--border);
  padding: 0 28px;
  height: 56px;
  display: flex;
  align-items: center;
  gap: 14px;
  position: sticky;
  top: 0;
  z-index: 100;
  box-shadow: var(--shadow-sm);
}

#topbar .logo {
  font-family: var(--font-code);
  font-size: 14px;
  color: var(--blue);
  font-weight: 600;
  letter-spacing: .02em;
  white-space: nowrap;
}

#topbar .logo span {
  color: var(--text-dim);
  font-weight: 400;
}

#topbar .doc-title {
  font-size: 14px;
  font-weight: 400;
  color: var(--text-muted);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

#topbar .sep {
  color: var(--border);
}

#view-toggle {
  margin-left: auto;
  display: flex;
  align-items: center;
  background: var(--surface-alt);
  border: 1px solid var(--border);
  border-radius: 99px;
  padding: 3px;
  gap: 2px;
}

#view-toggle label {
  font-family: var(--font-code);
  font-size: 11px;
  font-weight: 500;
  padding: 3px 12px;
  border-radius: 99px;
  cursor: pointer;
  color: var(--text-muted);
  transition: background .15s, color .15s;
  user-select: none;
  white-space: nowrap;
}

#view-toggle input[type=radio] {
  display: none;
}

#view-toggle input[type=radio]:checked+label {
  background: var(--blue);
  color: #fff;
  box-shadow: 0 1px 3px rgba(37, 99, 235, .25);
}

#notebook {
  padding: 48px 60px;
  overflow-y: auto;
  overflow-x: hidden;
}

#lean-raw {
  display: none;
  padding: 48px 60px;
  max-width: none;
  grid-column: 2;
  overflow: auto;
}

#lean-raw pre {
  background: var(--code-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 24px;
  font-family: var(--font-code);
  font-size: 13px;
  line-height: 1.7;
  tab-size: 2;
  overflow-x: auto;
  box-shadow: var(--shadow-sm);
  white-space: pre;
}

#app.lean-mode {
  grid-template-columns: 0 1fr;
}

#app.lean-mode #sidebar {
  display: none;
}

#app.lean-mode #lean-raw {
  grid-column: 1 / -1;
  padding: 48px 60px;
  display: block;
}

@media(max-width:900px) {
  #app {
    grid-template-columns: 1fr;
  }

  #app #sidebar {
    display: none;
  }

  #notebook {
    padding: 28px 20px;
  }

  #lean-raw {
    grid-column: 1;
    padding: 28px 20px;
  }
}

/* ---- Sidebar ---- */
#sidebar {
  background: var(--surface);
  border-right: 1px solid var(--border);
  overflow-y: auto;
  padding: 20px 0;
  position: sticky;
  top: 0;
  height: 100vh;
}

#toc-label {
  font-size: 10px;
  font-weight: 600;
  letter-spacing: .12em;
  text-transform: uppercase;
  color: var(--text-dim);
  padding: 0 18px 10px;
}

#toc a {
  display: block;
  padding: 4px 18px;
  font-size: 12.5px;
  color: var(--text-muted);
  text-decoration: none;
  transition: color .15s, background .15s;
  line-height: 1.5;
  border-left: 2px solid transparent;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

#toc a:hover {
  color: var(--blue);
  background: var(--blue-pale);
  border-left-color: var(--blue-light);
}

#toc a.h1 {
  font-weight: 600;
  color: var(--text);
  padding-left: 18px;
  margin-top: 6px;
}

#toc a.h2 {
  padding-left: 28px;
}

#toc a.h3 {
  padding-left: 40px;
  font-size: 11.5px;
}

/* ---- Main Content ---- */
#notebook {
  min-width: 0;
  width: 100%;
}

/* ================================================================
   Prose Blocks (shared)
   ================================================================ */
.block-module-doc,
.block-doc-comment {
  font-family: var(--font-prose);
  font-size: 17px;
  line-height: 1.85;
  color: var(--text);
  margin-bottom: 10px;
}

/* --- module-doc: white card --- */
.block-module-doc {
  padding: 32px 36px;
  background: var(--surface);
  border: 1px solid var(--border-soft);
  border-radius: var(--radius);
  box-shadow: var(--shadow-sm);
}

/* --- doc-comment: left blue border --- */
.block-doc-comment {
  padding: 16px 20px;
  border-left: 3px solid var(--blue-light);
  background: var(--blue-pale);
  border-radius: 0 var(--radius) var(--radius) 0;
}

/* ================================================================
   Prose Typography (shared)
   ================================================================ */
.block-module-doc h1,
.block-doc-comment h1,
.block-doc-comment h1,
.block-doc-comment h1 {
  font-size: 1.9em;
  font-weight: 600;
  color: var(--blue-dark);
  border-bottom: 2px solid var(--blue-pale);
  padding-bottom: 10px;
  margin: 0 0 20px;
  line-height: 1.3;
}

.block-module-doc h2,
.block-doc-comment h2,
.block-doc-comment h2,
.block-doc-comment h2 {
  font-size: 1.35em;
  font-weight: 600;
  color: var(--blue);
  margin: 24px 0 14px;
  line-height: 1.4;
}

.block-module-doc h3,
.block-doc-comment h3,
.block-doc-comment h3,
.block-doc-comment h3 {
  font-size: 1.1em;
  font-weight: 600;
  color: var(--text);
  margin: 18px 0 10px;
}

.block-module-doc h4,
.block-doc-comment h4,
.block-doc-comment h4,
.block-doc-comment h4 {
  font-size: 1em;
  font-weight: 600;
  color: var(--text-muted);
  margin: 14px 0 8px;
}

.block-module-doc p,
.block-doc-comment p,
.block-doc-comment p,
.block-doc-comment p {
  margin: 0 0 12px;
}

/* Remove bottom margin from the last child to keep padding visually equal */
.block-module-doc>*:last-child,
.block-doc-comment>*:last-child,
.block-doc-comment>*:last-child,
.block-doc-comment>*:last-child {
  margin-bottom: 0;
}

/* Remove top margin from the first child to keep padding visually equal */
.block-module-doc>*:first-child,
.block-doc-comment>*:first-child,
.block-doc-comment>*:first-child,
.block-doc-comment>*:first-child {
  margin-top: 0;
}

.block-module-doc strong,
.block-doc-comment strong,
.block-doc-comment strong,
.block-doc-comment strong {
  color: var(--text);
  font-weight: 600;
}

.block-module-doc em,
.block-doc-comment em,
.block-doc-comment em,
.block-doc-comment em {
  color: var(--text-muted);
  font-style: italic;
}

.block-module-doc ul,
.block-module-doc ol,
.block-doc-comment ul,
.block-doc-comment ol,
.block-doc-comment ul,
.block-doc-comment ol,
.block-doc-comment ul,
.block-doc-comment ol {
  margin: 8px 0 14px 22px;
}

.block-module-doc li,
.block-doc-comment li,
.block-doc-comment li,
.block-doc-comment li {
  margin-bottom: 5px;
}

.block-module-doc li p,
.block-doc-comment li p,
.block-doc-comment li p,
.block-doc-comment li p {
  margin: 0;
}

/* Inline code */
.block-module-doc code,
.block-doc-comment code,
.block-doc-comment code,
.block-doc-comment code {
  font-family: var(--font-code);
  font-size: .84em;
  background: var(--surface-alt);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 1px 5px;
  color: var(--blue-dark);
}

/* Code fences */
.block-module-doc pre,
.block-doc-comment pre,
.block-doc-comment pre,
.block-doc-comment pre {
  background: var(--code-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 14px 16px;
  overflow-x: auto;
  margin: 12px 0;
  font-family: var(--font-code);
  font-size: 13px;
  line-height: 1.7;
  tab-size: 2;
}

.block-module-doc pre code,
.block-doc-comment pre code,
.block-doc-comment pre code,
.block-doc-comment pre code {
  background: none;
  border: none;
  padding: 0;
  color: var(--text);
  font-size: inherit;
}

/* Tables */
.block-module-doc table,
.block-doc-comment table,
.block-doc-comment table,
.block-doc-comment table {
  border-collapse: collapse;
  width: 100%;
  margin: 16px 0;
  font-family: var(--font-ui);
  font-size: 14px;
}

.block-module-doc th,
.block-doc-comment th,
.block-doc-comment th,
.block-doc-comment th {
  background: var(--surface-alt);
  color: var(--blue-dark);
  font-weight: 600;
  padding: 8px 14px;
  text-align: left;
  border: 1px solid var(--border);
}

.block-module-doc td,
.block-doc-comment td,
.block-doc-comment td,
.block-doc-comment td {
  padding: 7px 14px;
  border: 1px solid var(--border);
  color: var(--text);
}

.block-module-doc tr:nth-child(even) td,
.block-doc-comment tr:nth-child(even) td,
.block-doc-comment tr:nth-child(even) td,
.block-doc-comment tr:nth-child(even) td {
  background: #f0f5fd;
}

/* Blockquotes */
.block-module-doc blockquote,
.block-doc-comment blockquote,
.block-doc-comment blockquote,
.block-doc-comment blockquote {
  border-left: 3px solid var(--blue-dim);
  padding-left: 16px;
  margin: 12px 0;
  color: var(--text-muted);
  font-style: italic;
}

.block-module-doc hr,
.block-doc-comment hr,
.block-doc-comment hr,
.block-doc-comment hr {
  border: none;
  border-top: 1px solid var(--border);
  margin: 24px 0;
}

.block-module-doc a,
.block-doc-comment a,
.block-doc-comment a,
.block-doc-comment a {
  color: var(--blue);
  text-decoration: none;
}

.block-module-doc a:hover,
.block-doc-comment a:hover,
.block-doc-comment a:hover,
.block-doc-comment a:hover {
  text-decoration: underline;
}

/* ================================================================
   Code Blocks
   ================================================================ */
.block-code {
  margin-bottom: 10px;
  border-radius: var(--radius);
  overflow: hidden;
  border: 1px solid var(--border);
  box-shadow: var(--shadow-sm);
}

.block-code-header {
  background: var(--surface-alt);
  padding: 7px 16px;
  font-family: var(--font-code);
  font-size: 11px;
  color: var(--text-dim);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  gap: 8px;
}

.block-code-header::before {
  content: '';
  display: inline-block;
  width: 7px;
  height: 7px;
  border-radius: 50%;
  background: var(--blue-light);
  opacity: .7;
}

.lean-source {
  background: var(--code-bg);
  margin: 0;
  padding: 18px 20px;
  font-family: var(--font-code);
  font-size: 13.5px;
  line-height: 1.7;
  white-space: pre;
  overflow-x: auto;
  tab-size: 2;
  color: var(--text);
}

/* ================================================================
   Syntax Highlighting
   ================================================================ */
.hl-keyword {
  color: var(--hl-keyword);
  font-weight: 600;
}

.hl-tactic {
  color: var(--hl-tactic);
}

.hl-type {
  color: var(--hl-type);
}

.hl-string {
  color: var(--hl-string);
}

.hl-number {
  color: var(--hl-number);
}

.hl-comment {
  color: var(--hl-comment);
  font-style: italic;
}

.hl-op {
  color: var(--hl-op);
}

/* ================================================================
   Mermaid Blocks
   ================================================================ */
.block-mermaid {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 28px 24px;
  margin-bottom: 10px;
  overflow-x: auto;
  overflow-y: visible;
  box-shadow: var(--shadow-sm);
}

.block-mermaid svg {
  height: auto;
}

.block-mermaid .error {
  color: #c00;
  padding: 1em;
  border-radius: 4px;
  text-align: left;
}

/* ================================================================
   Graphviz (DOT) Blocks
   ================================================================ */
.block-graphviz {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 28px 24px;
  margin-bottom: 10px;
  overflow-x: auto;
  overflow-y: visible;
  box-shadow: var(--shadow-sm);
}

.block-graphviz svg {
  height: auto;
}

.block-graphviz .error {
  color: #c00;
  padding: 1em;
  border-radius: 4px;
  text-align: left;
}

/* ================================================================
   MathJax
   ================================================================ */
mjx-container {
  color: inherit !important;
}

mjx-container[display="true"] {
  display: block !important;
  overflow: visible !important;
  margin: 0 !important;
  max-width: 100%;
  font-size: 1.15em;
}

.mjx-display-wrap {
  overflow-x: auto;
  overflow-y: hidden;
  margin: 20px 0;
  padding: 4px 0;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: thin;
  scrollbar-color: var(--blue-dim) transparent;
}

.mjx-display-wrap::-webkit-scrollbar {
  height: 4px;
}

.mjx-display-wrap::-webkit-scrollbar-track {
  background: transparent;
}

.mjx-display-wrap::-webkit-scrollbar-thumb {
  background: var(--blue-dim);
  border-radius: 2px;
}

/* Heading scroll offset */
h1,
h2,
h3,
h4,
h5,
h6 {
  scroll-margin-top: 72px;
}

/* ================================================================
   Scrollbar
   ================================================================ */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-track {
  background: transparent;
}

::-webkit-scrollbar-thumb {
  background: var(--blue-dim);
  border-radius: 3px;
}

/* ================================================================
   Lean LSP Output (#eval / proof status)
   ================================================================ */
.lean-output {
  border-top: 1px solid var(--border);
  padding: 10px 10px 10px 22px;
  background: rgba(0, 0, 0, .02);
  position: relative;
}

.lean-output::before {
  content: "";
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 4px;
  background: var(--blue);
}

.output-label {
  display: block;
  font-size: .78em;
  color: var(--text-muted);
  font-weight: 600;
  margin-bottom: 4px;
  text-transform: uppercase;
}

.lean-output pre {
  margin: 0;
  font-family: var(--font-code);
  white-space: pre-wrap;
  font-size: 13px;
}
  </style>
</head>

<body>
  <script type="text/x-lean-source" id="lean-source">namespace CL8E8TQC.Foundation

/-!
# Generation Hierarchy of the Clifford Algebra Cl(8)

## Abstract

**Position**: Chapter 1 of the `_01_TQC` module. This file serves as the starting point and connects to `_02_PinSpin.lean`.

**Subject of this chapter**: Representing the 256-dimensional basis space of Clifford algebra Cl(8) with `BitVec 8`, and constructing and formally proving the generation hierarchy theorem Cl(8) = ‚ü®E8‚ü© ‚äÉ Cl_even(8) = ‚ü®D8‚ü© ‚äÉ ‚ü®H84‚ü© using only integer arithmetic.

**Main results**:
- ‚ü®E8‚ü© = Cl(8): Proof that 240 E8 roots generate all 256 basis elements
- ‚ü®D8‚ü© = Cl_even(8): Proof that 112 D8 roots generate the 128-dimensional even subalgebra
- ‚ü®H84‚ü© = 16-dimensional subalgebra: Proof that H84 codewords are closed under XOR and the geometric product

## Main definitions

* `Cl8Basis` - The 256 basis elements of Cl(8) (BitVec 8 representation)
* `geometricProduct` - Clifford geometric product (XOR + parity sign)
* `isE8Root` - E8 root basis predicate (= complement of H84, 240 elements)
* `isD8Sector` - D8 sector basis predicate (even-weight non-H84, 112 elements)
* `isSpinorSector` - Spinor sector basis predicate (odd-weight, 128 elements)
* `h84Codewords` - The 16 codewords of the H84 code
* `H84` - Type for H84 codewords (16 elements)

## Main statements

* **‚ü®E8‚ü© = Cl(8)**: E8 roots ‚äá all unit vectors ‚Üí XOR generation reaches all 256 bases (¬ß3.3)
* **‚ü®D8‚ü© = Cl_even(8)**: D8 roots ‚äá all weight-2 elements ‚Üí generates all even-weight elements (¬ß4.3)
* **‚ü®H84‚ü© = 16-dim subalgebra**: H84 is closed under XOR and the geometric product (¬ß5)
* Geometric product closure: The geometric product of Cl(8) preserves the 8-bit space (¬ß3.2)
* Self-duality: The H84 code satisfies $C = C^\perp$ (¬ß5.4)
* **Algebraic foundation of Triality-QEC**: Self-duality ‚Üí doubly-even property ‚Üí subalgebra closure (¬ß5.5)
  - `h84IntersectionEven_true`: Intersection weight of codeword pairs is always even (¬ß5.5)
  - `h84IsSubalgebra_true`: H84 satisfies the 3 subalgebra conditions over GF(2) (¬ß5.5)
  - `verifyTrialityQECFoundation_true`: Collective verification of the above (¬ß5.5)

## Implementation notes

- **Forbidden Float**: All operations implemented using only integers and Booleans
- **Matrix-Free**: Matrix representations eliminated; all operations performed via the geometric product (XOR + sign)
- **Bitwise Geometric Product**: Geometric product via XOR + swapCount
- **Integer Normalization**: Normalization by scale factor 4 (detailed in ¬ß5)

**Type design**:
- `Cl8Basis = BitVec 8`: Uses a type designed as a bit string
- `BitVec 8` has high affinity with `getLsb` and `bv_decide`, suitable for this purpose
- `abbrev weight`: Alias for `grade` (for coding theory contexts)
- `isOrthogonalGF2`: Orthogonality predicate over GF(2)
- `E8Root.isRoot`: Provable representation via Boolean predicate

**Data structures (Array-First)**:
- `List` eliminated: All sequences unified to `Array`
- DRY via the `filterBases` common helper
- Index-based generation via `Array.ofFn`

**Control structures (Pure Functional HOF)**:
- `for` loops eliminated
- `Array.foldl`, `Array.all`, `Array.map`, `Array.filter`
- Uniform use of `Œª` symbol

**Verification strategy**:
- All theorems computationally verified via `native_decide`
- Zero usage of `Float` type (Forbidden Float principle)
- All operations within `Int`, `Nat`, `Bool`, `BitVec 8` (Matrix-Free principle)

## Tags

clifford-algebra, e8-lattice, d8-lattice, h84-code, geometric-product,
bitwise-operations, generation-hierarchy, forbidden-float
-/

/-!

# ¬ß0. Epistemological Labeling: Distinguishing ‚úÖ and üöÄ

## 0.1 Why the Distinction Matters

This module `_01_TQC` constructs a bitwise implementation of Clifford algebra Cl(8)
by combining "established algebra" with "novel computational constructions."
Without clear labeling, the following confusions easily arise:

- Mathematically **proven** algebraic facts may appear to be "original hypotheses"
- **Constructive identifications** original to this theory may appear to be "trivial facts"

Such confusion makes it impossible to evaluate the theory.
Therefore, **the epistemological status is explicitly stated at the beginning of every section**.

## 0.2 Label Definitions

| Label | Meaning | Criterion |
|:---|:---|:---|
| ‚úÖ **[ESTABLISHED]** | Established mathematical fact | Found in textbooks or peer-reviewed papers. Anyone who computes obtains the same result |
| üöÄ **[NOVEL]** | Construction, identification, or interpretation original to this theory | Adds new implementation or interpretation to known mathematics, or performs original computations |

## 0.3 Concrete Examples in This Chapter

| Claim | Label | Reason |
|:---|:---|:---|
| Cl(8) has $2^8 = 256$ basis elements | ‚úÖ | Standard result in Clifford algebra |
| XOR of `BitVec 8` is isomorphic to the basis part of the geometric product | üöÄ | The **constructive identification** of this isomorphism is original to this theory |
| The E8 lattice has 240 roots | ‚úÖ | Standard result of Conway‚ÄìSloane |
| E8 roots = complement of H84 codewords (256 ‚àí 16 = 240) | üöÄ | The **identification** via bit patterns is original to this theory |
| H(8,4) is a self-dual code ($C = C^\perp$) | ‚úÖ | Standard result in coding theory |
| H84 forms a 16-dimensional subalgebra of Cl(8) | üöÄ | The **construction** as a subalgebra is original to this theory |
| Cl(8) ‚âÖ $M_{16}(\mathbb{R})$ (Bott periodicity) | ‚úÖ | Standard result of Lawson‚ÄìMichelsohn |
| Forbidden Float & Matrix-Free principles | üöÄ | The **definition of these principles** as design policy is original to this theory |

## 0.4 What This Means for the Reader

- Sections labeled ‚úÖ are **independently verifiable**: simply cross-reference with textbooks
- Sections labeled üöÄ should be **read critically**: examine premises, constructions, and identifications at each stage
- Verification via Lean's `native_decide` establishes computational facts **regardless of** the ‚úÖ/üöÄ distinction

---

# ¬ß1. Mathematical Foundations of Clifford Algebra Cl(8) ‚úÖ [ESTABLISHED]

## 1.1 The 8-Bit Space and Clifford Basis

Clifford algebra Cl(8) is the algebra generated from the 8-dimensional Euclidean space $\mathbb{R}^8$.
It has $2^8 = 256$ basis elements, represented here as `Cl8Basis` (= `BitVec 8`).

**Classification of Clifford algebras** (Bott periodicity):

By the classification of real Clifford algebras (mod 8 periodicity), the following isomorphism holds:

$$\text{Cl}_{8,0}(\mathbb{R}) \cong M_{16}(\mathbb{R})$$

That is, Cl(8) is isomorphic to the $16 \times 16$ real matrix ring, and its unique irreducible representation is the 16-dimensional real spinor representation $S_{16}$.

**Note**: The Clifford algebra of signature $(0,8)$ yields the same matrix ring:
$\text{Cl}_{0,8}(\mathbb{R}) \cong M_{16}(\mathbb{R})$.
This is a consequence of Bott periodicity ($\text{Cl}(n+8) \cong \text{Cl}(n) \otimes M_{16}(\mathbb{R})$)
and the agreement of the classification table at $n = 8$. This is distinct from Triality (the symmetry among the 3 representations of Spin(8); see ¬ß6).

Reference: Lawson, H.B. & Michelsohn, M.-L. (1989). *Spin Geometry*, Princeton University Press.

**‚Üí See ¬ß5**: The correspondence between the dimension 16 of this irreducible representation and the 16 codewords of H(8,4) is detailed in ¬ß5.

## 1.2 Clifford Basis

Each bit pattern `b : Cl8Basis` represents a basis element of the Clifford algebra:

$$e_I = e_{i_1} \wedge e_{i_2} \wedge \cdots \wedge e_{i_k}$$

where $I = \{i_1, i_2, \ldots, i_k\} \subseteq \{0,1,\ldots,7\}$ is the set of bit positions that are 1 in the bit pattern `b`.

**Examples**:
```
0b00000001#8 = e‚ÇÄ         (grade-1: vector)
0b00000011#8 = e‚ÇÄ ‚àß e‚ÇÅ    (grade-2: bivector)
0b11111111#8 = e‚ÇÄ‚àß...‚àße‚Çá  (grade-8: pseudoscalar)
0b00000000#8 = 1           (grade-0: scalar)
```

**This 256-dimensional space is, as shown in ¬ß3, the algebra itself generated by the E8 roots.**
-/

/-! ## 1.3 Definition of the Cl8Basis Type -/

/-- 8-bit patterns correspond to the 256 basis elements of Cl(8).

**Rationale for type choice**:
- `BitVec 8` is designed as a "bit string," directly representing the essence of Clifford bases (subsets of the index set I)
- Bit-position access via `getLsb` is explicit
- Proof automation via the `bv_decide` tactic is available

**Bit interpretation**:
- Bit i is set ‚ü∫ basis $e_i$ is included
- `0b00000011#8` = $e_0 \wedge e_1$
- `0b11111111#8` = $e_0 \wedge e_1 \wedge \cdots \wedge e_7$ (pseudoscalar)
-/
abbrev Cl8Basis : Type := BitVec 8

/-! ## 1.4 Grade (Degree) Computation -/

/-- The grade of a basis element $e_I$ equals $|I|$.
In the bit pattern representation, this is the number of set bits.

**Properties**:
- grade 0: scalar (1 element)
- grade 1: vector (8 elements)
- grade 2: bivector (28 elements)
- ...
- grade 8: pseudoscalar (1 element)

Total: $\sum_{k=0}^{8} \binom{8}{k} = 2^8 = 256$

**Implementation**: Scans each bit position via `BitVec.getLsb` and accumulates using `foldl` over `Array.range 8`
-/
def grade : Cl8Basis ‚Üí Nat :=
  Œª b =>
    (Array.range 8).foldl
       (Œª count (i : Nat) =>
         if h : i < 8 then
            -- Note: Array.range 8 produces only 0..7, so this branch is always true.
            -- Required for type safety: promotion to Fin 8 via ‚ü®i, h‚ü©.
           if b.getLsb ‚ü®i, h‚ü© then count + 1 else count
         else
           count)
       0

/-! ## 1.5 Definitions of Basic Basis Elements -/

/-- Scalar (identity element) -/
def scalar : Cl8Basis := 0b00000000#8

/-- The k-th basis vector ($e_k$)

**Arguments**:
- `k : Fin 8` - Vector index (0‚Äì7)

**Returns**: BitVec 8 bit pattern (only the k-th bit is 1)
-/
def basisVector : Fin 8 ‚Üí Cl8Basis :=
  Œª k =>
    BitVec.ofNat 8 (1 <<< k.val)

/-- Pseudoscalar ($e_0 \wedge e_1 \wedge \cdots \wedge e_7$) -/
def pseudoScalar : Cl8Basis := 0b11111111#8

/-! ## 1.6 Verification of Basis Element Properties -/

theorem grade_scalar : grade scalar = 0 :=
  by native_decide
theorem grade_basisVector0 : grade (basisVector 0) = 1 :=
  by native_decide
theorem grade_basisVector7 : grade (basisVector 7) = 1 :=
  by native_decide
theorem grade_pseudoScalar : grade pseudoScalar = 8 :=
  by native_decide

/-!
---

# ¬ß2. Implementing the Geometric Product via BitVec 8 üöÄ [NOVEL]

**Epistemological status of this section**:

- Established in ¬ß1: The geometric product of a Clifford algebra satisfies $e_I \cdot e_J = \pm e_{I \triangle J}$ ‚úÖ
- **Constructive identification in this section** üöÄ: That the XOR (`^^^`) of `BitVec 8` is algebraically isomorphic to the basis part of the geometric product, and the integer implementation of the AND-braiding sign. This identification makes the CPU's ALU itself a Clifford algebra computation engine.

## 2.1 Mathematical Definition of the Geometric Product

The core of a Clifford algebra is the **geometric product** (Clifford product).
For vectors $v, w \in \mathbb{R}^8$:

$$v w = \langle v, w \rangle + v \wedge w$$

(where the left-hand side $vw$ is the geometric product, $\langle v, w \rangle$ on the right is the inner product, and $v \wedge w$ is the exterior product).

**Key to bitwise implementation**:

The geometric product of two basis elements $e_I, e_J$ is:

$$e_I \cdot e_J = (-1)^{\text{parity}(I,J)} \cdot e_{I \triangle J}$$

where:
- $I \triangle J$: symmetric difference (XOR)
- $\text{parity}(I,J)$: parity of the braiding (number of transpositions)
-/

/-! ## 2.2 Definition of Auxiliary Functions -/

/-- XOR-based basis fusion (raw computation ignoring the sign)

**Mathematical meaning**:

Computation of the symmetric difference $I \triangle J$.

**Usage**: Intermediate step when computing the basis part of the geometric product.
-/
def fusionRaw : Cl8Basis ‚Üí Cl8Basis ‚Üí Cl8Basis :=
  Œª a b =>
    a ^^^ b

/-- Braiding count (number of transpositions to determine the sign)

**Detailed explanation**:

When computing the product of two basis elements $e_I, e_J$,
this counts how many times elements of $e_I$ must be "swapped past" elements of $e_J$.

**Algorithm**:

$I = \{i_1, i_2, \ldots\}$ (ascending order)
$J = \{j_1, j_2, \ldots\}$ (ascending order)

For each $i_k \in I$, count the number of $j_l \in J$ such that $j_l < i_k$.

**Bitwise implementation**:

Scans each bit position via `foldl` over `Array.range 8`, accumulating the count.
The mask `(1 <<< i) - 1` extracts bits below position i, and `grade` counts them.
-/
def swapCount : Cl8Basis ‚Üí Cl8Basis ‚Üí Nat :=
  Œª a b =>
    (Array.range 8).foldl
      (Œª count (i : Nat) =>
        if h : i < 8 then
          if a.getLsb ‚ü®i, h‚ü© then
            count + grade (b &&& BitVec.ofNat 8 ((1 <<< i) - 1))
          else count
        else count)
      0

-- Tests for swapCount
theorem swapCount_e0_e1 : swapCount (basisVector 0) (basisVector 1) = 0 :=
  by native_decide
theorem swapCount_e1_e0 : swapCount (basisVector 1) (basisVector 0) = 1 :=
  by native_decide
theorem swapCount_e2_e0 : swapCount (basisVector 2) (basisVector 0) = 1 :=
  by native_decide
theorem swapCount_e3_e1 : swapCount (basisVector 3) (basisVector 1) = 1 :=
  by native_decide

/-- Computation of braiding parity

Computes how many anticommutative swaps are required in the product of two basis elements $e_I, e_J$.

**Mathematical definition**:

$$\text{parity}(I, J) = |\\{(i,j) \mid i \in I, j \in J, i > j\\}| \mod 2$$

**Implementation**: Checks the parity (odd/even) of the `swapCount` function's result.
-/
def isBraidingOdd : Cl8Basis ‚Üí Cl8Basis ‚Üí Bool :=
  Œª a b =>
    swapCount a b % 2 == 1

/-! ## 2.3 Implementation of the Geometric Product -/

/-- Computes the geometric product of two basis elements.

**Mathematical definition**:

$$e_I \cdot e_J = (-1)^{\text{parity}(I,J)} \cdot e_{I \triangle J}$$

**Return value**:
- `.fst`: Basis of the product (XOR)
- `.snd`: Sign (true = negative, false = positive)

**Examples**:
```
e‚ÇÄ ¬∑ e‚ÇÅ = e‚ÇÄ‚àße‚ÇÅ         (positive)
e‚ÇÅ ¬∑ e‚ÇÄ = -e‚ÇÄ‚àße‚ÇÅ        (negative)
e‚ÇÄ ¬∑ e‚ÇÄ = 1             (positive)
```
-/
def geometricProduct : Cl8Basis ‚Üí Cl8Basis ‚Üí Cl8Basis √ó Bool :=
  Œª a b =>
    (a ^^^ b, isBraidingOdd a b)

/-! ## 2.4 Verification of Basic Properties of the Geometric Product -/

-- e‚ÇÄ ¬∑ e‚ÇÄ = 1
theorem geomProd_e0_e0 : geometricProduct (basisVector 0) (basisVector 0) = (0b00000000#8, false) :=
  by native_decide

-- e‚ÇÄ ¬∑ e‚ÇÅ = e‚ÇÄ‚àße‚ÇÅ (positive)
theorem geomProd_e0_e1 : geometricProduct (basisVector 0) (basisVector 1) = (0b00000011#8, false) :=
  by native_decide

-- e‚ÇÅ ¬∑ e‚ÇÄ = -e‚ÇÄ‚àße‚ÇÅ (negative)
theorem geomProd_e1_e0 : geometricProduct (basisVector 1) (basisVector 0) = (0b00000011#8, true) :=
  by native_decide

/-!
---

# ¬ß3. Cl(8) = ‚ü®E8‚ü©: Identifying the Overall Structure üöÄ [NOVEL]

**Epistemological status of this section**:

- Established in ¬ß1: There are 240 E8 roots ‚úÖ
- **Identification in this section** üöÄ: Constructive proof that these 240 roots exactly coincide with the complement of the extended Hamming code H(8,4) in the `BitVec 8` space, and that they generate all of Cl(8).

This section proves that the 256-dimensional Clifford algebra Cl(8) constructed in ¬ß1
is **identical to** the algebra generated by the 240 E8 roots.

## 3.1 The Fundamental Decomposition 256 = 16 + 240

The set of all 8-bit patterns (256 elements) decomposes into the 16 codewords of the H(8,4) extended Hamming code and its complement, the 240 E8 roots:

$$\text{Cl}(8) = \text{H84}(16) \sqcup \text{E8 roots}(240)$$

To perform this decomposition, we first define the H84 codewords.
-/

/-- Computation of weight (Hamming weight)

Computes the number of set bits in a bit pattern.

The coding theory term "weight" is the same computation as the Clifford algebraic "grade."
We define an alias via `abbrev` so that the appropriate terminology can be used in each mathematical context.

**Usage convention**: `grade` in a Clifford algebra context; `weight` in a coding theory context.
-/
abbrev weight : Cl8Basis ‚Üí Nat := grade

/-- The 16 codewords of the H(8,4) extended Hamming code

These form a linear code that is closed under XOR.
**Important**: The condition "weight ‚àà {0, 4, 8}" alone is insufficient (that yields 72 elements).
The H(8,4) code consists of only the 16 that satisfy the special doubly-even condition.

**Mathematical properties**:
- Doubly-even: Every codeword has weight divisible by 4
- Self-dual: $C = C^\perp$ (the code coincides with its dual)
- Minimum distance: 4
- 16 codewords: 1 of weight 0, 14 of weight 4, 1 of weight 8
-/
def h84Codewords : Array Cl8Basis :=
  #[
    0x00#8, 0x17#8, 0x2B#8, 0x3C#8, 0x4D#8, 0x5A#8, 0x66#8, 0x71#8,
    0x8E#8, 0x99#8, 0xA5#8, 0xB2#8, 0xC3#8, 0xD4#8, 0xE8#8, 0xFF#8
  ]

theorem h84Codewords_size_16 : h84Codewords.size = 16 :=
  by native_decide

/-- H84 code membership predicate -/
def isH84 : Cl8Basis ‚Üí Bool :=
  Œª b => h84Codewords.contains b

/-- E8 root basis predicate (240 elements)

**Core definition**: E8 roots are the **complement** of H84 codewords.

$$\text{isE8Root}(b) \iff \neg\text{isH84}(b)$$

**Equivalence**: This definition is equivalent to the former `isD8Sector(b) || isSpinorSector(b)`.
H84 consists of 16 doubly-even elements with weight ‚àà {0,4,8}; the remaining 240 are E8 roots.
-/
def isE8Root : Cl8Basis ‚Üí Bool :=
  Œª b => !isH84 b

/-- Common helper to enumerate all Cl8Basis elements satisfying a predicate from all 256 -/
def filterBases : (Cl8Basis ‚Üí Bool) ‚Üí Array Cl8Basis :=
  Œª pred =>
    (Array.range 256)
      |>.filter (Œª b => pred (BitVec.ofNat 8 b))
      |>.map (Œª b => BitVec.ofNat 8 b)

/-- Complete list of E8 roots -/
def e8Roots : Array Cl8Basis := filterBases isE8Root

theorem e8Roots_size : e8Roots.size = 240 :=
  by native_decide

/-!
## 3.2 Geometric Product Closure of Cl(8)

**Theorem**: The geometric product of Cl(8) preserves the space of 256 8-bit patterns.

**Proof**: Since `geometricProduct(a, b).fst = a ^^^ b`,
and the XOR of two `BitVec 8` values is always a `BitVec 8`.

This fact may appear trivial, but it is fundamentally important:
- It guarantees that operations on the E8 lattice **never leave** the 8-bit space
- It provides the foundation for the Weyl group action to be completed within a finite space
- It is the algebraic basis that makes the Forbidden Float principle possible
-/

/-- Computational verification of geometric product closure of Cl(8)

Verifies that all $256 \times 256 = 65536$ geometric products lie within the 256 basis elements.
-/
def verifyCl8Closure : Bool :=
  (Array.range 256).all (Œª a =>
    (Array.range 256).all (Œª b =>
      let av := BitVec.ofNat 8 a
      let bv := BitVec.ofNat 8 b
      let (result, _) := geometricProduct av bv
      result.toNat < 256))

theorem verifyCl8Closure_true : verifyCl8Closure = true :=
  by native_decide

/-!
## 3.3 Generation Theorem: ‚ü®E8‚ü© = Cl(8)

**Theorem**: All 256 basis elements can be generated by the geometric product (fusion = XOR) of the 240 E8 roots.

**Proof**:

1. All 8 unit vectors $e_0, e_1, \ldots, e_7$ have weight 1 (odd)
2. Odd-weight elements are not contained in H84 (H84 has weight ‚àà {0,4,8} only)
3. Therefore $\{e_0, \ldots, e_7\} \subset \text{E8 roots}$
4. Any `BitVec 8` can be expressed as the XOR of unit vectors at its set bit positions
5. By ¬ß3.2, the geometric product is closed within the 8-bit space
6. Therefore $\langle\text{E8}\rangle = \text{Cl}(8)$

**Corollary**: The geometric product of E8 roots generates all of Cl(8), but the E8 roots themselves are **not closed** under the geometric product (products can yield H84 elements). This is the important phenomenon of "a non-closed set generating the entire algebra."
-/

/-- Core verification of ‚ü®E8‚ü© = Cl(8): all unit vectors are E8 roots -/
def allUnitVectorsAreE8 : Bool :=
  (Array.range 8).all (Œª i => isE8Root (BitVec.ofNat 8 (1 <<< i)))

theorem allUnitVectorsAreE8_true : allUnitVectorsAreE8 = true :=
  by native_decide
-- ‚à¥ {e‚ÇÄ,...,e‚Çá} ‚äÇ E8 roots
-- ‚à¥ Any BitVec 8 can be expressed as XOR of unit vectors
-- ‚à¥ ‚ü®E8‚ü© = Cl(8)

/-!
## 3.4 Properties of E8 Roots

Type definition for E8 lattice roots and verification of their basic properties.
-/

/-- Type for roots of the E8 lattice

A subtype of `Cl8Basis` satisfying `isE8Root`.
Since `isRoot : isE8Root basis = true` is a Boolean predicate,
it can be proved for concrete values via `decide` or `native_decide`.
-/
structure E8Root where
  basis : Cl8Basis
  isRoot : isE8Root basis = true

/-!
**Important property**:

All E8 roots have normalized norm 2:

$$|r|^2 = 2 \quad \forall r \in \text{E8 roots}$$

This property is the foundation for the integer arithmetic implementation of
the Householder reflection formula (see `_03_QuantumState.lean`).

---

# ¬ß4. Cl_even(8) = ‚ü®D8‚ü©: Even‚ÄìOdd Decomposition and Subalgebra üöÄ [NOVEL]

**Epistemological status of this section**:

- The root system of the D8 lattice consists of 112 elements ‚úÖ
- **Identification in this section** üöÄ: Constructive proof that these correspond exactly to the 128 even-grade bases in the `BitVec 8` space, and that they generate Cl_even(8).

Having established Cl(8) = ‚ü®E8‚ü© in ¬ß3, we now descend to the natural subspace of Cl(8): the **even-grade subalgebra** Cl_even(8).

## 4.1 Decomposition by Grade Parity

Cl(8) decomposes into two subspaces according to grade parity:

$$\text{Cl}(8) = \text{Cl}_{\text{even}}(8) \oplus \text{Cl}_{\text{odd}}(8)$$

- $\text{Cl}_{\text{even}}(8)$: Elements of even grade (0,2,4,6,8) ‚Üí **128 elements**
- $\text{Cl}_{\text{odd}}(8)$: Elements of odd grade (1,3,5,7) ‚Üí **128 elements**

**Important**: $\text{Cl}_{\text{even}}(8)$ is closed under the geometric product and forms a **subalgebra**.

**Grade stratification**:

| Grade | Count | Components | Algebraic role |
|:---:|---:|:---|:---|
| 0 | 1 | Scalar | Identity |
| 1 | 8 | Spinor | Vector |
| 2 | 28 | D8 root | Bivector |
| 3 | 56 | Spinor | Trivector |
| 4 | 70 | **H84 (14) + D8 (56)** | **Middle layer** |
| 5 | 56 | Spinor | (dual of grade 3) |
| 6 | 28 | D8 root | (dual of grade 2) |
| 7 | 8 | Spinor | (dual of grade 1) |
| 8 | 1 | Pseudoscalar (H84) | (dual of grade 0) |

**Note**: Grade (Hamming weight) and coordinate-space norm are different concepts.
All E8 roots have norm¬≤ = 2, but their grades span 1‚Äì7.
-/

/-- Even-grade predicate

Determines whether a basis element has even grade.
Even-grade elements are generated by products of an even number of vectors.
-/
def isEven : Cl8Basis ‚Üí Bool :=
  Œª b =>
    grade b % 2 == 0

theorem isEven_scalar : isEven scalar = true :=
  by native_decide
theorem isEven_basisVector0 : isEven (basisVector 0) = false :=
  by native_decide
theorem isEven_pseudoScalar : isEven pseudoScalar = true :=
  by native_decide

/-- Even subalgebra closure test

Verifies that the product of two even-grade basis elements has even grade.
-/
def testEvenClosure : Cl8Basis ‚Üí Cl8Basis ‚Üí Bool :=
  Œª a b =>
    if isEven a && isEven b then
      isEven (geometricProduct a b).fst
    else true

theorem testEvenClosure_scalar_scalar : testEvenClosure scalar scalar = true :=
  by native_decide
theorem testEvenClosure_e01_e23 : testEvenClosure (basisVector 0 ^^^ basisVector 1) (basisVector 2 ^^^ basisVector 3) = true :=
  by native_decide

/-!
## 4.2 D8 Sector and Spinor Sector

The 240 E8 roots decompose into two sectors according to grade parity:

$$240 = 112 \text{ (D8 sector: even-weight non-H84)} + 128 \text{ (Spinor sector: odd-weight)}$$

### 4.2.1 D8 Sector (112 elements)

Corresponds to the roots of the D8 lattice. Even-weight bases that are not H84 codewords.

**Weight breakdown**:
1. Weight 2: $\binom{8}{2}$ = 28 (pure D8 root bases $e_i \wedge e_j$)
2. Weight 6: $\binom{8}{6}$ = 28 (duals of D8 roots)
3. Weight 4 (non-H84): $\binom{8}{4} - 14$ = 56

**Correspondence with coordinate space**:

The D8 lattice is known as the root system $D_8$:
$$D_8 = \{(x_1, \ldots, x_8) \in \mathbb{Z}^8 \mid x_1 + \cdots + x_8 \equiv 0 \pmod{2}\}$$

The shortest vectors (roots) are $\{\pm e_i \pm e_j \mid 1 \le i < j \le 8\}$,
numbering $\binom{8}{2} \times 4 = 112$.
-/

/-- D8 sector basis predicate (112 elements)

Even-weight bases that are not in H84.
-/
def isD8Sector : Cl8Basis ‚Üí Bool :=
  Œª b =>
    let w := weight b
    (w == 2) || (w == 6) || (w == 4 && !isH84 b)

def d8SectorBases : Array Cl8Basis := filterBases isD8Sector

theorem d8SectorBases_size : d8SectorBases.size = 112 :=
  by native_decide

/-!
### 4.2.2 Spinor Sector (128 elements)

All bases of odd weight (1, 3, 5, 7).
In the original theory, these are called "half-integer vectors":
$$(1/2, 1/2, 1/2, 1/2, 1/2, 1/2, 1/2, 1/2) + \text{even number of coordinate reflections}$$

**Correspondence with bit patterns**:
Bit $i$ is 1 ‚ü∫ coordinate $i$ is $+1/2$; bit $i$ is 0 ‚ü∫ coordinate $i$ is $-1/2$.
Odd Hamming weight ‚ü∫ odd number of $+1/2$ coordinates ‚ü∫ half-odd coordinate sum.

**Composition**: 8 + 56 + 56 + 8 = 128 elements
-/

/-- Spinor sector basis predicate (128 elements) -/
def isSpinorSector : Cl8Basis ‚Üí Bool :=
  Œª b =>
    weight b % 2 == 1

def spinorSectorBases : Array Cl8Basis := filterBases isSpinorSector

theorem spinorSectorBases_size : spinorSectorBases.size = 128 :=
  by native_decide

/-!
### Verification of E8 = D8 ‚à™ Spinor

That the 240 E8 roots are the exclusive union of D8 (112) and Spinor (128)
follows immediately from the definition `isE8Root = !isH84` and the fact
that H84 only has even weights (weight ‚àà {0,4,8}).

## 4.3 Generation Theorem: ‚ü®D8‚ü© = Cl_even(8)

**Theorem**: All 128 even-weight elements can be generated by the fusion (XOR) of the 112 D8 roots.

**Proof**:

1. All weight-2 elements $\{e_i \oplus e_j \mid i < j\}$ (28 elements) are contained in the D8 sector
2. Any even-weight element can be expressed as an XOR chain of weight-2 elements
   (simply pair up the set bits in groups of two)
3. Therefore $\langle\text{D8}\rangle_{\text{XOR}} = \text{all even-weight elements} = 128$
4. $\langle\text{D8}\rangle = \text{Cl}_{\text{even}}(8)$
-/

/-- Core verification of ‚ü®D8‚ü© = Cl_even(8): all weight-2 elements are in the D8 sector -/
def allWeight2AreD8 : Bool :=
  (Array.range 256).all (Œª b =>
    let bv := BitVec.ofNat 8 b
    if weight bv == 2 then isD8Sector bv else true)

theorem allWeight2AreD8_true : allWeight2AreD8 = true :=
  by native_decide
-- ‚à¥ D8 ‚äá {e·µ¢‚äïe‚±º | i<j} (all 28 weight-2 elements)
-- ‚à¥ Any even-weight element can be expressed as an XOR chain of weight-2 elements
-- ‚à¥ ‚ü®D8‚ü© = Cl_even(8)

/-!
---

# ¬ß5. ‚ü®H84‚ü© = 16-Dimensional Subalgebra: The Deepest Level of the Structure üöÄ [NOVEL]

**Epistemological status of this section**:

- The existence and properties of the H(8,4) code (minimum distance = 4, self-duality) are established coding theory ‚úÖ
- **Identification in this section** üöÄ: Constructive proof that these 16 codewords form a **subalgebra** within the bit patterns of Cl(8), closed under both XOR and the geometric product.

The deepest level of the generation hierarchy. The 16 codewords of the H84 code
form a **subalgebra** closed under both XOR and the geometric product.

## 5.1 Type and Search for H84 Codewords

`h84Codewords` is defined in ¬ß2.1. Here we develop its detailed properties.

**List of codewords**:
- Weight 0: `0b00000000` (scalar) ‚Äî 1 element
- Weight 4: 14 doubly-even codewords
- Weight 8: `0b11111111` (pseudoscalar) ‚Äî 1 element
-/

/-- Type for H84 codewords (with constraint)

A subtype that admits only the 16 codewords.
-/
def H84 : Type := { b : Cl8Basis // isH84 b = true }

/-- Proof that h84Codewords has size 16 -/
theorem h84Codewords_size : h84Codewords.size = 16 :=
  by native_decide

/-- Proof that all elements of h84Codewords satisfy isH84 -/
theorem h84_mem_isH84 : ‚àÄ b ‚àà h84Codewords, isH84 b = true :=
  by native_decide

/-- Proof that the codeword at any index satisfies isH84 -/
theorem h84_at_index : ‚àÄ (i : Fin 16), isH84 h84Codewords[i.val] = true :=
  by native_decide

/-- Conversion from index to codeword

**Implementation**: By `h84_at_index`, for any `Fin 16`,
`isH84 h84Codewords[i] = true` is guaranteed,
so the construction can be done directly without branching.
-/
def fromIndex : Fin 16 ‚Üí H84 :=
  Œª i => ‚ü®h84Codewords[i.val], h84_at_index i‚ü©

theorem fromIndex_0_val : (fromIndex 0).val = 0x00#8 :=
  by native_decide
theorem fromIndex_1_val : (fromIndex 1).val = 0x17#8 :=
  by native_decide
theorem fromIndex_15_val : (fromIndex 15).val = 0xFF#8 :=
  by native_decide

/-- Codeword index table (for reverse lookup) -/
def codewordIndexTable : Array (Option (Fin 16)) :=
  Array.ofFn (Œª (i : Fin 256) =>
    h84Codewords.findIdx? (¬∑ == BitVec.ofNat 8 i.val)
      |>.map (Œª idx =>
        if h : idx < 16 then ‚ü®idx, h‚ü© else ‚ü®0, by decide‚ü©))

/-- Search for the index of a codeword -/
def findCodewordIndex : Cl8Basis ‚Üí Option (Fin 16) :=
  Œª b =>
    codewordIndexTable[b.toNat]!

theorem findCodewordIndex_0 : findCodewordIndex 0#8 = some 0 :=
  by native_decide
theorem findCodewordIndex_0x17 : findCodewordIndex 0x17#8 = some 1 :=
  by native_decide
theorem findCodewordIndex_0xFF : findCodewordIndex 0xFF#8 = some 15 :=
  by native_decide
theorem findCodewordIndex_0x01 : findCodewordIndex 0b00000001#8 = none :=
  by native_decide

/-!
## 5.2 XOR Closure

H84 is a linear code, and the XOR of any two codewords is again an H84 codeword.
-/

/-- Verification of H84 XOR closure -/
def h84XorClosure : Bool :=
  h84Codewords.all (Œª c1 =>
    h84Codewords.all (Œª c2 =>
      isH84 (c1 ^^^ c2)))

theorem h84XorClosure_true : h84XorClosure = true :=
  by native_decide

/-!
## 5.3 Geometric Product Closure

**Theorem**: The 16 codewords of H84 are closed under the Clifford geometric product.

$$\forall c_1, c_2 \in \text{H84}: \quad c_1 \cdot c_2 = \pm c_3 \quad (c_3 \in \text{H84})$$

**Proof**: Computational verification of all $16 \times 16 = 256$ cases.
-/

/-- Verification of subalgebra closure -/
def verifyH84Closure : Bool :=
  h84Codewords.all (Œª c1 =>
    h84Codewords.all (Œª c2 =>
      isH84 (geometricProduct c1 c2).fst))

theorem verifyH84Closure_true : verifyH84Closure = true :=
  by native_decide

/-- Complete closure table (16√ó16) -/
def h84ClosureTable : Array (Array (Cl8Basis √ó Bool)) :=
  Array.ofFn (Œª (i : Fin 16) =>
    Array.ofFn (Œª (j : Fin 16) =>
      let c1 := h84Codewords[i.val]
      let c2 := h84Codewords[j.val]
      geometricProduct c1 c2))

theorem h84ClosureTable_size : h84ClosureTable.size = 16 :=
  by native_decide
theorem h84ClosureTable_row0_size : h84ClosureTable[0]!.size = 16 :=
  by native_decide
theorem h84ClosureTable_0_0 : h84ClosureTable[0]![0]! = (0b00000000#8, false) :=
  by native_decide
theorem h84ClosureTable_1_1 : h84ClosureTable[1]![1]! = (0b00000000#8, false) :=
  by native_decide
theorem h84ClosureTable_0_1 : h84ClosureTable[0]![1]! = (0x17#8, false) :=
  by native_decide

/-- Complete verification of closure (all 256 cases) -/
def verifyH84ClosureComplete : Bool :=
  h84ClosureTable.all (Œª row =>
    row.all (Œª (prod, _) => isH84 prod))

theorem verifyH84ClosureComplete_true : verifyH84ClosureComplete = true :=
  by native_decide

/-!
## 5.4 Self-Duality

The H(8,4) code is a self-dual code: $C = C^\perp$
-/

/-- Orthogonality predicate over GF(2)

Returns true when the popcount of the AND of two bit patterns is even (= GF(2) inner product is 0).
-/
def isOrthogonalGF2 : Cl8Basis ‚Üí Cl8Basis ‚Üí Bool :=
  Œª a b =>
    grade (a &&& b) % 2 == 0

/-- Verification of self-duality: C ‚äÜ C‚ä• -/
def verifySelfDuality : Bool :=
  h84Codewords.all (Œª c1 =>
    h84Codewords.all (Œª c2 =>
      c1 == c2 || isOrthogonalGF2 c1 c2))

theorem verifySelfDuality_true : verifySelfDuality = true :=
  by native_decide

/-- Verification of the reverse direction of self-duality: C‚ä• ‚äÜ C

For all 256 bit patterns, verifies that if a pattern is orthogonal to all H84 codewords, then it is in H84.
This completes the full proof that $C = C^\perp$.
-/
def verifySelfDualityReverse : Bool :=
  (Array.range 256).all (Œª b =>
    let bv := BitVec.ofNat 8 b
    let orthToAll := h84Codewords.all (Œª c => isOrthogonalGF2 bv c)
    !orthToAll || isH84 bv)

theorem verifySelfDualityReverse_true : verifySelfDualityReverse = true :=
  by native_decide

/-!
## 5.5 Closure Structure of the H84 Subalgebra: From Self-Duality to Subalgebra Property

This section rigorously argues, via propositions verifiable by `native_decide`, that the closure of H84 is not a "coincidental numerical agreement" but rather an **algebraic structure necessarily derived** from self-duality $C = C^\perp$.

**‚Üí Forward reference**: The quantum-computational significance of this closure structure (Triality-QEC) is developed in `_03_QuantumState.lean`, building on the Triality of Spin(8) (`_02_PinSpin.lean` ¬ß6) and the definition of the quantum state space.

### Outline of the Argument

For H84 to form a subalgebra of Cl(8), operations between codewords must not escape the code space‚Äîthat is, **algebraic closure** is required.

This closure is not accidental; it is necessarily derived from the **self-duality C = C‚ä•** of H(8,4) (¬ß5.4).
The argument proceeds in three stages:

```
[Stage 1] Self-duality of H(8,4) (C = C‚ä•)          ‚Üê Proved in ¬ß5.4
           ‚Üì GF(2) inner product is zero ‚Üí "overlap" of codewords is always even
[Stage 2] Geometric product of any 2 codewords is closed in the code space ‚Üê Proved in ¬ß5.3
           ‚Üì Operation results never escape the code space = subalgebra closure
[Stage 3] H84 forms a 16-dimensional subalgebra of Cl(8)
           ‚Üì Subalgebra = self-contained operational system
```

### Stage 1: Self-Duality Implies "Even Intersection"

Self-duality `verifySelfDuality_true` (¬ß5.4) guarantees:
For any two codewords c1, c2 ‚àà H84, `grade(c1 &&& c2) % 2 = 0`.

This means that in the sign computation (swapCount) of the geometric product, the number of common bits between c1 and c2 is always even, providing the basis for "the sign structure being maintained coherently when codewords are Clifford-multiplied."

**Note**: For `c1 = c2`, this holds from the doubly-even property (weight ‚àà {0,4,8});
for `c1 ‚â† c2`, it holds from self-duality. These are independently established.
-/

/-- Consequence of the doubly-even property and self-duality of H(8,4): the intersection weight of any two codewords is even

For `c1 ‚â† c2`, this holds from self-duality (C = C‚ä•); for `c1 = c2`, it holds from
the doubly-even property (weight ‚àà {0,4,8}). These are independently established.

This is the algebraic basis for the coherence of sign computation in the geometric product.
-/
def h84IntersectionEven : Bool :=
  h84Codewords.all (Œª c1 =>
    h84Codewords.all (Œª c2 =>
      grade (c1 &&& c2) % 2 == 0))

theorem h84IntersectionEven_true : h84IntersectionEven = true :=
  by native_decide

/-!
### Stage 2: Closure Implies "Self-Containment of the Code Space"

`verifyH84Closure_true` (¬ß5.3) proves that "the Clifford product of H84 codewords is closed in H84."
Algebraically, this means:

> **"The result of every operation always remains within the code space."**

`h84GeomProdClosed` is definitionally identical to `verifyH84Closure` (¬ß5.3),
provided as an alias for explicit reference in the Triality-QEC context.
-/

/-- H84 geometric product closure (explicit reference of `verifyH84Closure` from ¬ß4.3 in the Triality-QEC context)

Verifies that the basis of the Clifford product of H84 codewords is always an H84 codeword (all 256 cases).
Alias for `verifyH84Closure` (¬ß4.3). Enables context-appropriate referencing.
-/
abbrev h84GeomProdClosed : Bool := verifyH84Closure

theorem h84GeomProdClosed_true : h84GeomProdClosed = true :=
  by native_decide

/-!
### Stage 3: H84 Forms a Basis Set of a (GF(2)-Coefficient) Subalgebra of Cl(8)

The following 3 conditions are verified:

1. **Inclusion of multiplicative identity**: 0b00000000 (scalar `1`) ‚àà H84
2. **XOR closure** (GF(2) addition): c1 ‚äï c2 ‚àà H84 (`h84XorClosure_true`, proved in ¬ß4.2)
3. **Geometric product closure**: c1 ¬∑ c2 ‚àà H84 (`h84GeomProdClosed_true`, proved in Stage 2)

**Note**: As a subalgebra of a real-coefficient Clifford algebra, scalar-multiple closure (‚Ñù-coefficient linear combinations) is additionally required, but since this implementation treats bases as sets (GF(2) linear code of BitVec 8), the above 3 conditions are the corresponding subalgebra conditions.
-/

/-- Simultaneous verification of the 3 subalgebra conditions for H84 (GF(2)-coefficient model)

(1) Contains the multiplicative identity (scalar `1 = 0b00000000`)
(2) Closed under XOR (GF(2) addition)
(3) Closed under the geometric product
-/
def h84IsSubalgebra : Bool :=
  -- (1) Inclusion of multiplicative identity
  isH84 scalar &&
  -- (2) XOR closure (GF(2) addition)
  h84XorClosure &&
  -- (3) Geometric product closure
  h84GeomProdClosed

theorem h84IsSubalgebra_true : h84IsSubalgebra = true :=
  by native_decide

/-!
### Completion of the Argument: Self-Duality ‚Üí Subalgebra

**Theorem (Closure Structure of the H84 Subalgebra)**:

The self-duality ($C = C^\perp$) of H(8,4) guarantees that the 16 codewords of H84 form a **basis set of a subalgebra** in Clifford algebra Cl(8).

| Proved proposition | Meaning | Algebraic role |
|:---|:---|:---|
| `h84IntersectionEven_true` | Intersection of codeword pairs is always even | Consequence of doubly-even property and self-duality |
| `h84GeomProdClosed_true` | Geometric product is closed in H84 | Self-containment of code space |
| `h84IsSubalgebra_true` | H84 satisfies the 3 subalgebra conditions | Constructive proof of GF(2)-coefficient subalgebra |
| `verifySelfDuality_true` | $C = C^\perp$ | Basis for closure structure |

**Why this is more precise than an "anticommutation condition"**:

The claim `d_H(c1, c2) = 4 ‚ü∫ {Œì_{c1}, Œì_{c2}} = 0` is
false in the standard Cl(8) (all distance-4 pairs actually commute).
In contrast, **closure as a subalgebra** is a rigorous proposition fully verified by `native_decide`,
precisely capturing that "operation results never escape the code space."

**‚Üí Forward reference**: How this closure structure functions as Triality-QEC
by combining the Triality representation of Spin(8) (_02 ¬ß6)
and the quantum state space (_03) is argued in the final section of `_03_QuantumState.lean`.
-/

/-- Complete verification of the algebraic foundation of Triality-QEC

Collective verification from self-duality through subalgebra closure,
covering the entire algebraic foundation of Triality-QEC.
-/
def verifyTrialityQECFoundation : Bool :=
  -- Self-duality (C = C‚ä•)
  verifySelfDuality &&
  verifySelfDualityReverse &&
  -- Even intersection (consequence of doubly-even property and self-duality)
  h84IntersectionEven &&
  -- 3 subalgebra conditions
  h84IsSubalgebra

theorem verifyTrialityQECFoundation_true : verifyTrialityQECFoundation = true :=
  by native_decide

/-!
## 5.6 Completion of the Generation Hierarchy

The above establishes three generation theorems:

| Generators | Count | Closure | Generated subalgebra | Dimension |
|--------|------|--------|----------------|------|
| H84 codewords | 16 | ‚úÖ Closed | ‚ü®H84‚ü© | 16 |
| D8 roots | 112 | ‚ùå Not closed | ‚ü®D8‚ü© = Cl_even(8) | 128 |
| E8 roots | 240 | ‚ùå Not closed | ‚ü®E8‚ü© = Cl(8) | 256 |

$$\text{Cl}(8) = \langle\text{E8}\rangle \supset \text{Cl}_{\text{even}}(8) = \langle\text{D8}\rangle \supset \langle\text{H84}\rangle$$

**Three aspects of the inclusion relation:**

| Aspect | Cl(8) | Cl_even(8) | ‚ü®H84‚ü© |
|:---|:---|:---|:---|
| **Dimension** | 256 | 128 | 16 |
| **Grade** | All 0‚Äì8 | Even only | {0,4,8} |
| **Symmetry** | E8 Weyl group | D8 Weyl group | H84 linear code |
| **Generator count** | 240 | 112 | 16 |
| **8-bit condition** | All 256 | Even weight | Weight ‚àà {0,4,8} doubly-even |

**Hierarchy diagram:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Cl(8) = ‚ü®E8‚ü© = 256-dimensional                  ‚îÇ
‚îÇ  ‚Ä¢ Grade: 0,1,2,...,8 (all)                      ‚îÇ
‚îÇ  ‚Ä¢ E8 Weyl group |W(E8)| = 696,729,600           ‚îÇ
‚îÇ  ‚Ä¢ 8-bit: all 256 (0x00‚Äì0xFF)                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚äÉ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Cl_even(8) = ‚ü®D8‚ü© = 128-dimensional              ‚îÇ
‚îÇ  ‚Ä¢ Grade: 0,2,4,6,8 (even only)                  ‚îÇ
‚îÇ  ‚Ä¢ D8 Weyl group = 2‚Å∑¬∑8!                          ‚îÇ
‚îÇ  ‚Ä¢ 8-bit: 128 even-weight elements                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚äÉ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ‚ü®H84‚ü© = 16-dimensional                           ‚îÇ
‚îÇ  ‚Ä¢ Grade: 0,4,8 only                              ‚îÇ
‚îÇ  ‚Ä¢ Linear code (XOR-closed, geom. product-closed)  ‚îÇ
‚îÇ  ‚Ä¢ 8-bit: 16 doubly-even elements                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## 5.7 Complementarity: Why Both H84 and E8 Roots Are Necessary

$$\text{Cl}(8) = \text{H84}(16) \sqcup \text{E8 roots}(240)$$

This decomposition is **exclusive and complementary**.

**H84 alone (16 elements):**
- Closed under XOR, but confined within 16 elements
- No new structure emerges ‚Üí a "dead universe"
- Only a static skeleton, no dynamic interactions

**E8 roots alone (240 elements):**
- Not closed under the geometric product (products can yield H84 elements)
- No "foundation" to receive the results of operations ‚Üí "laws without substance"

**H84 + E8 roots (256 elements): A complete universe:**
- Static skeleton (H84) + dynamic interactions (E8 roots) = the entire Clifford algebra
- Every geometric product is completed within the 256 bases (proved in ¬ß3.2)
- E8 roots generate all of Cl(8) (proved in ¬ß3.3)

**Three independent proofs of exclusivity:**
1. **Weight classification**: H84 has {0,4,8}; E8 roots have mixed even/odd {1,2,3,5,6,7}
2. **Closure**: H84 is closed; E8 roots are not
3. **Algebraic role**: H84 is the static foundation; E8 roots are the dynamic generators

## 5.8 Abelian vs Non-Abelian Distinction

Each level of the generation hierarchy also differs qualitatively in the **commutativity** of the algebra.

| Observable | Algebraic structure | Commutativity | Algebraic position |
|:---|:---|:---:|:---|
| **H84 codewords only** | Clifford group | ‚úÖ Abelian | Within the scope of the Gottesman‚ÄìKnill theorem |
| **E8 roots (D8 part)** | Non-Clifford | ‚ùå **Non-Abelian** | Algebraically transcends the Clifford group |

**Clifford group (Abelian part)**:

Operators constructed from H84 codewords commute with each other, and their phases close under combinations of $\{\pi/4, \pi/2, \pi\}$.
Algebra: $\mathbb{Q}(\sqrt{2}, i)$

**E8 root operators (Non-Abelian)**:

Distinct D8 roots $u \cdot v$ and $u' \cdot v'$ are generally non-commutative: $[u \cdot v, u' \cdot v'] \neq 0$
Phases include $2\pi/3$.
Algebra: $\mathbb{Z}[\omega]$ where $\omega = e^{i2\pi/3}$

**Geometric reason for the breaking of commutativity**:

The 60¬∞ vector angle structure between D8-part roots of the E8 lattice generates 120¬∞ spinor rotations via the Cartan‚ÄìDieudonn√© theorem. The phase $\omega = e^{i2\pi/3}$ accompanying this rotation is a unit of the Eisenstein integers $\mathbb{Z}[\omega]$, satisfying $\omega^3 = 1$ and $1 + \omega + \omega^2 = 0$ (primitive cube root of unity). Since $\omega \notin \mathbb{Q}(\sqrt{2}, i)$, E8 root operators algebraically transcend the Clifford group, giving rise to non-Abelian behavior.

## 5.9 Weyl Group Symmetry and Bridge to `_03_QuantumState.lean`

A corresponding Weyl group acts on each level of the generation hierarchy.

**E8 Weyl group W(E8):**
- Order: |W(E8)| = 696,729,600
- Generation: Reflections by 240 roots $v \mapsto v - 2\frac{\langle v, r \rangle}{\langle r, r \rangle} r$
- Action space: The 256-dimensional space of Cl(8)
- 8-bit implementation: `reflection(v, r) = -r¬∑v¬∑r‚Åª¬π` (sandwich product)

**D8 Weyl group W(D8):**
- Order: |W(D8)| = 2‚Å∑ ¬∑ 8! = 5,160,960
- Structure: Signed permutation group (7 independent sign choices √ó permutations of 8 elements)
- Action space: The 128-dimensional subspace of Cl_even(8)

**8-bit closure of reflection operations:**

All reflection operations preserve the space of 256 8-bit patterns:
$$\forall v \in \{0\text{x}00\ldots0\text{x}FF\}, \forall r \in \text{E8 roots}: \quad \text{reflection}(v, r) \in \{0\text{x}00\ldots0\text{x}FF\}$$

This property provides the theoretical basis for implementing Weyl rotations using only integer arithmetic in `_03_QuantumState.lean` (application to quantum computation).

**State transitions via the geometric product:**
```
Initial state v‚ÇÄ ‚Üí geom. product √ó r‚ÇÅ ‚Üí v‚ÇÅ ‚Üí geom. product √ó r‚ÇÇ ‚Üí v‚ÇÇ ‚Üí ‚ãØ
Forever cycling within 256 8-bit values (the symmetry of E8 is never broken)
```

---

# ¬ß6. Integer Normalization and the Conway‚ÄìSloane Construction

## 6.0 Epistemological Status

- **¬ß6.1 Conway‚ÄìSloane Construction A** ‚úÖ [ESTABLISHED]: Standard construction method of Lawson‚ÄìMichelsohn and Conway‚ÄìSloane
- **¬ß6.2 Integer Normalization Strategy of This Implementation** üöÄ [NOVEL]: The choice of scale factor 4 and its adaptation to the bitwise implementation are original to this theory

## 6.1 Conway‚ÄìSloane Construction A ‚úÖ [ESTABLISHED]

The classical construction by Conway‚ÄìSloane:

**Theorem**: A unimodular lattice $\Lambda$ can be constructed from a self-dual binary code $C$.

$$\Lambda = \\{(x_1, \ldots, x_n) \in \mathbb{R}^n \mid 2x \in \mathbb{Z}^n, x \bmod 2 \in C\\}$$

For the H84 code:

$$\text{E8} = \frac{1}{\sqrt{2}} \\{\text{lattice generated from H84}\\}$$

## 6.2 Integer Normalization Strategy üöÄ [NOVEL]

### 6.2.1 Integer Normalization of This Implementation

This implementation uses integer normalization with a scale factor of **4**:

**Integer coefficient representation of codewords (scale factor 4)**
- Purpose: Represent the coefficients of linear combinations of codewords directly as integers $a_i \in \mathbb{Z}$
- Theoretical basis: Harmonizes with the doubly-even property (weight ‚àà {0, 4, 8}) of the H(8,4) code

**Relationship with the Conway‚ÄìSloane standard form**:

```
Conway-Sloane:  (1,1,0,0,0,0,0,0)  |r|¬≤ = 2
This impl:      0b00000011          weight = 2
Correspondence:  ‚àö2 scaling relationship
```

This correspondence is for theoretical reference only; **‚àö2 is never used in the implementation**.

### 6.2.2 Representation of Codeword Coefficients

**Representation via integer coefficients**:
$$\sum_{i=0}^{15} a_i \cdot c_i, \quad a_i \in \mathbb{Z}$$

Integer coefficients $a_i$ are directly defined for each basis $c_i$.

**Concrete example** (uniform-weight state):
```
Integer coefficients: a_i = 1  (i = 0, 1, ..., 15)
Array representation: [1, 1, 1, ..., 1]
```

### 6.2.3 Theoretical Basis for Scale Factor 4

The codewords of the H84 code have Hamming weight only in {0, 4, 8} (multiples of 4).

For the uniform-weight state, each codeword's coefficient is the integer 1.
The scale factor **N = 4** is a normalization constant that harmonizes with the doubly-even property.

| Standard representation | Integer representation |
|:---:|:---:|
| 1/4 | 1 |
| 1/2 | 2 |
| 1 | 4 |

### 6.2.4 Integer Closure of Operations

All basic operations are completed within the integer domain:

#### 6.2.4.1 Geometric Product

```lean
geometricProduct : Cl8Basis ‚Üí Cl8Basis ‚Üí (Cl8Basis √ó Bool)
```

- The result consists only of a codeword (basis) and a sign
- Amplitude does not change
- Closed within the integer domain

#### 2. Bitwise Operations

```lean
XOR       : Cl8Basis ‚Üí Cl8Basis ‚Üí Cl8Basis    -- Fusion
Grade     : Cl8Basis ‚Üí Nat                     -- Grade determination
SwapCount : Cl8Basis ‚Üí Cl8Basis ‚Üí Nat          -- Sign determination
```

- All integer operations
- No rounding errors
- Deterministic computation

## 6.3 Formal Verifiability

Integer normalization provides:
- ‚úÖ **Exact equality testing**: No floating-point errors
- ‚úÖ **Deterministic computation**: All operations are reproducible
- ‚úÖ **Formal proofs possible**: Implementation in theorem-proving systems is feasible

---

# ¬ß7. Matrix-Free Principle ‚Äî Cl(8) Does Not Require Matrix Representations

## 7.0 Epistemological Status

- **¬ß7.1 Theorem (Matrix-Free)** ‚úÖ [ESTABLISHED]: The algebraic fact that the geometric product is completed by XOR + sign (constructed in ¬ß2)
- **¬ß7.4 Principle Declaration** üöÄ [NOVEL]: Codifying this fact as a "design principle" is original to this theory

From the integer normalization of ¬ß5 and the XOR structure of the geometric product, all operations of Cl(8) **reduce to bit operations** without passing through matrix representations. This is not an implementation optimization but a **structural property of the algebra**.

## 7.1 Theorem: The Geometric Product Is a Bit Operation ‚úÖ [ESTABLISHED]

**Theorem (Matrix-Free)**: The geometric product $e_a \cdot e_b$ of Cl(8) is completely computed by the following two bit operations:

1. **Basis determination**: $e_a \cdot e_b \mapsto \pm e_{a \oplus b}$ (XOR operation)
2. **Sign determination**: $\text{sign}(a, b) \in \{+1, -1\}$ (swap count)

No matrix construction, multiplication, or inversion is required.

**Proof**:
- Step 1: From $\gamma_i^2 = 1$, duplicate generators cancel, and the result is $e_{a \oplus b}$
- Step 2: The sign = $(-1)^{\sum_{i < j} a_j \cdot b_i}$ is computable in $O(8^2) = O(1)$

**Consequence**: The rank of the kernel matrix is at most 8 (since the basis of ¬ß1 has 8 elements). $\quad \square$

## 7.2 Computational Complexity Comparison

| Operation | Matrix representation | CL8E8TQC | Ratio |
|:---|:---|:---|:---|
| $e_a \cdot e_b$ | $O(256^2)$ matrix multiplication | $O(1)$ XOR + swap_count | $65536 : 1$ |
| $u \cdot x \cdot u$ (reflection) | $O(256^3)$ | $O(1)$ XOR√ó2 | $10^7 : 1$ |
| QuantumState reflection | $O(256^3)$ | $O(256)$ | $65536 : 1$ |

## 7.3 Matrix-Free Verification of All Operations
-/

/-- Verification that the geometric product is completed by XOR + sign

Verifies that for all $256 \times 256 = 65536$ pairs, the result basis equals `a ‚äï b`.
-/
def verifyXorStructure : Bool :=
  (Array.range 256).all (Œª i =>
    (Array.range 256).all (Œª j =>
      let a := BitVec.ofNat 8 i
      let b := BitVec.ofNat 8 j
      let (result, _isNeg) := geometricProduct a b
      result == (a ^^^ b)))

theorem verifyXorStructure_true : verifyXorStructure = true :=
  by native_decide
-- true: basis = XOR for all 65536 pairs

/-- Verification of anticommutativity: e·µ¢ ¬∑ e‚±º = -e‚±º ¬∑ e·µ¢ (i ‚â† j) -/
def verifyAnticommutation : Bool :=
  (Array.range 8).all (Œª i =>
    (Array.range 8).all (Œª j =>
      if i == j then true
      else
        let ei := BitVec.ofNat 8 (1 <<< i)
        let ej := BitVec.ofNat 8 (1 <<< j)
        let (_, s1) := geometricProduct ei ej
        let (_, s2) := geometricProduct ej ei
        s1 != s2))

theorem verifyAnticommutation_true : verifyAnticommutation = true :=
  by native_decide
-- true: Œ≥·µ¢ ¬∑ Œ≥‚±º = -Œ≥‚±º ¬∑ Œ≥·µ¢

/-- Verification of associativity: (e‚Çê ¬∑ e·µ£) ¬∑ e·µ® = e‚Çê ¬∑ (e·µ£ ¬∑ e·µ®) -/
def verifyAssociativity : Nat ‚Üí Bool :=
  Œª samples =>
  (Array.range samples).all (Œª s =>
    let a := BitVec.ofNat 8 ((s * 37 + 13) % 256)
    let b := BitVec.ofNat 8 ((s * 71 + 29) % 256)
    let c := BitVec.ofNat 8 ((s * 113 + 47) % 256)
    let (ab, s1) := geometricProduct a b
    let (abc_l, s2) := geometricProduct ab c
    let sign_l := s1 != s2
    let (bc, s3) := geometricProduct b c
    let (abc_r, s4) := geometricProduct a bc
    let sign_r := s3 != s4
    abc_l == abc_r && sign_l == sign_r)

theorem verifyAssociativity_1000 : verifyAssociativity 1000 = true :=
  by native_decide
-- true: Associativity holds (no matrices)

/-- Verification of involution of reflection: u¬∑(u¬∑x¬∑u)¬∑u = x (no matrices) -/
def verifyReflectInvolution : Bool :=
  let u := 0b00000011#8
  (Array.range 256).all (Œª i =>
    let x := BitVec.ofNat 8 i
    let (ux, s1) := geometricProduct u x
    let (uxu, s2) := geometricProduct ux u
    let (u_uxu, s3) := geometricProduct u uxu
    let (result, s4) := geometricProduct u_uxu u
    let sign_first := s1 != s2
    let sign_second := s3 != s4
    let total_sign := sign_first != sign_second
    result == x && total_sign == false)

theorem verifyReflectInvolution_true : verifyReflectInvolution = true :=
  by native_decide
-- true: Reflection is an involution (no matrices)

/-!
## 7.4 Principle Declaration üöÄ [NOVEL]

**Matrix-Free Principle**: Execute all operations of Cl(8) without passing through matrix representations.

**Type constraints**:
```lean
‚úÖ Allowed: BitVec 8, Int, Nat, Bool, Array Int
‚ùå Forbidden: Matrix, Array (Array Int) used as a matrix
```

**Operation constraints**:
```lean
‚úÖ Allowed: XOR (^^^), AND (&&&), popcount, geometricProduct,
         dot product, addition/subtraction/multiplication
‚ùå Forbidden: Matrix multiplication, determinant, inverse matrix, eigenvalue decomposition
```

**Exception**: Constant-size (8√ó8) algebraic structures are permitted as linear maps on Cl(8) grade-1.

| Property | Verification | Result |
|:---|:---|:---|
| Geometric product = XOR + sign | All 65536 pairs | ‚úÖ |
| Anticommutativity | All 28 pairs | ‚úÖ |
| Associativity | 1000 samples | ‚úÖ |
| Involution of reflection | All 256 bases | ‚úÖ |
| Matrix usage | Entire operation catalog | ‚ùå Zero |

---

# ¬ß8. Integration of the Forbidden Float Principle & Matrix-Free Principle üöÄ [NOVEL]

Building on the integer normalization of ¬ß5 and the Matrix-Free theorem of ¬ß6, we establish two design principles in an integrated manner.

## 8.1 Integrated Principle

$$\boxed{
\text{CL8E8TQC Design Principle} = \text{Forbidden Float}
\;\cap\; \text{Matrix-Free}
= \text{Integer bit operations only}
}$$

| Principle | What is excluded | Basis |
|:---|:---|:---|
| **Forbidden Float** | Floating-point arithmetic | Integer normalization theorem (¬ß5) |
| **Matrix-Free** | Matrix representations and operations | Bit-operation representation of the geometric product (¬ß6) |

The two principles are **independent but coexist**:
- Forbidden Float constrains the **type of numerical values** (Float ‚Üí Int)
- Matrix-Free constrains the **structure of operations** (Matrix ‚Üí Geometric product)

**Operations satisfying both principles simultaneously**: Integer bit operations + dot product.
These coincide with the operations directly executed by the CPU's ALU.

## 8.2 The Forbidden Float Principle and Design Policy

**Principle**: No floating-point arithmetic is used at all.

**Type constraints**:
```lean
‚úÖ Allowed: BitVec 8, Int, Nat, Bool, Array Int
‚ùå Forbidden: Float, Double, Real
```

**Operation constraints**:
```lean
‚úÖ Allowed: +, -, *, ^, %, &&&, |||, ^^^, <, ==
‚ùå Forbidden: /, sqrt, sin, cos, exp, log
```

**Exception**: Real numbers may be used in mathematical expressions for theoretical explanation (within comments).

## 8.3 Problems with Floating-Point Arithmetic

**Problem 1: Accumulation of numerical errors**

```
0.1 + 0.2 = 0.30000000000000004
```

**Problem 2: Non-determinism**

Floating-point operations may produce subtly different results depending on the platform and optimization level.

**Problem 3: Difficulty of formal verification**

Complete formal verification of floating-point operations is extremely difficult.

## 8.4 Resolution via Integer Arithmetic
-/

/-- Integer vector inner product computation

**Implementation based on the Forbidden Float & Matrix-Free principles**:
No floating-point arithmetic is used; no matrices are used.
-/
def innerProduct_int : Array Int ‚Üí Array Int ‚Üí Int :=
  Œª v1 v2 =>
    (Array.range v1.size).foldl
      (Œª acc i => acc + v1[i]! * v2[i]!)
      0

/-!
**Advantages**:
1. ‚úÖ **Complete elimination of numerical errors**: No floating-point arithmetic used at all
2. ‚úÖ **Deterministic computation**: Platform-independent
3. ‚úÖ **Formally verifiable**: Proofs are straightforward
4. ‚úÖ **Bitwise affinity**: Natural integration with Cl8Basis

---

# ¬ß9. Summary

## 9.1 Generation Hierarchy Structure

The core result of this paper:

$$\text{Cl}(8) = \langle\text{E8}\rangle(256) \supset \text{Cl}_{\text{even}}(8) = \langle\text{D8}\rangle(128) \supset \langle\text{H84}\rangle(16)$$

1. ‚úÖ **‚ü®E8‚ü© = Cl(8)**: E8 roots ‚äá all unit vectors ‚Üí generates all 256 dimensions (¬ß3.3)
2. ‚úÖ **‚ü®D8‚ü© = Cl_even(8)**: D8 roots ‚äá all weight-2 elements ‚Üí generates the 128-dimensional even subalgebra (¬ß4.3)
3. ‚úÖ **‚ü®H84‚ü© = 16-dimensional subalgebra**: Closed under XOR and the geometric product ‚Äî the deepest level of the structure (¬ß5)
4. ‚úÖ **Geometric product closure**: The geometric product of Cl(8) preserves the 8-bit space (¬ß3.2)
5. ‚úÖ **Self-duality**: The H84 code satisfies $C = C^\perp$ (¬ß5.4)
6. ‚úÖ **Algebraic foundation of Triality-QEC**: Self-duality ‚Üí doubly-even property ‚Üí subalgebra closure (¬ß5.5)
7. ‚úÖ **Integer normalization**: Scale factor 4 (¬ß6)
8. ‚úÖ **Matrix-Free**: All operations are XOR + sign bit operations (¬ß7)
9. ‚úÖ **Forbidden Float & Matrix-Free**: Integrated design principle (¬ß8)

## 9.2 Theoretical Significance

### 9.2.1 Discovery of the Generation Hierarchy

The equation Cl(8) = ‚ü®E8‚ü© means that the algebra constructed with 8 bits
**is itself the algebra generated by E8**.

This discovery demonstrates that abstract mathematics (Clifford algebra, E8 lattice, coding theory)
and concrete implementation (BitVec 8, XOR, Boolean logic) are in **perfect correspondence**.

### 9.2.2 Innovation of Forbidden Float & Matrix-Free

This implementation is **not a simulation (approximate numerical imitation) of quantum computation**.
The CPU's bit operations are algebraically isomorphic to the operations of Clifford algebra Cl(8), and it is an algebraic implementation that **directly executes** quantum computation using only integers and Booleans.

## 9.3 Future Research Directions

The formal proofs in this chapter constitute the foundation of the `_01_TQC` module.
Building on these formal proofs, `_02_PinSpin.lean` develops the definitions and actions of Pin and Spin groups, and `_03_QuantumState.lean` develops the verification of E8 Weyl rotations and norm preservation.

## 9.4 Computational Verification List for All Theorems

All `native_decide` theorems in this paper have been computationally verified via `lake build`, and the results confirming agreement with the expected values stated in the document are shown below.

### Basis Structure Verification (¬ß1‚Äì¬ß2)

| Expression | Expected value | Check |
|:---|:---|:---:|
| `grade scalar` | 0 | ‚úÖ |
| `grade (basisVector 0)` | 1 | ‚úÖ |
| `grade (basisVector 7)` | 1 | ‚úÖ |
| `grade pseudoScalar` | 8 | ‚úÖ |
| `swapCount e‚ÇÄ e‚ÇÅ` | 0 | ‚úÖ |
| `swapCount e‚ÇÅ e‚ÇÄ` | 1 | ‚úÖ |
| `swapCount e‚ÇÇ e‚ÇÄ` | 1 | ‚úÖ |
| `swapCount e‚ÇÉ e‚ÇÅ` | 1 | ‚úÖ |
| `e‚ÇÄ ¬∑ e‚ÇÄ` | (0x00, false) | ‚úÖ |
| `e‚ÇÄ ¬∑ e‚ÇÅ` | (0x03, false) | ‚úÖ |
| `e‚ÇÅ ¬∑ e‚ÇÄ` | (0x03, true) | ‚úÖ |
| `isEven scalar` | true | ‚úÖ |
| `isEven (basisVector 0)` | false | ‚úÖ |
| `isEven pseudoScalar` | true | ‚úÖ |
| `testEvenClosure scalar scalar` | true | ‚úÖ |
| `testEvenClosure (e‚ÇÄ‚àße‚ÇÅ)(e‚ÇÇ‚àße‚ÇÉ)` | true | ‚úÖ |

### Generation Hierarchy Verification (¬ß3‚Äì¬ß5)

| Expression | Expected value | Check |
|:---|:---|:---:|
| `h84Codewords.size` | 16 | ‚úÖ |
| `e8Roots.size` | 240 | ‚úÖ |
| `verifyCl8Closure` | true | ‚úÖ |
| `allUnitVectorsAreE8` | true | ‚úÖ |
| `d8SectorBases.size` | 112 | ‚úÖ |
| `spinorSectorBases.size` | 128 | ‚úÖ |
| `allWeight2AreD8` | true | ‚úÖ |
| `h84XorClosure` | true | ‚úÖ |
| `verifyH84Closure` | true | ‚úÖ |
| `h84ClosureTable.size` | 16 | ‚úÖ |
| `h84ClosureTable[0]!.size` | 16 | ‚úÖ |
| `h84ClosureTable[0]![0]!` | (scalar, false) | ‚úÖ |
| `h84ClosureTable[1]![1]!` | (scalar, false) | ‚úÖ |
| `h84ClosureTable[0]![1]!` | (codeword 1, false) | ‚úÖ |
| `verifyH84ClosureComplete` | true | ‚úÖ |
| `verifySelfDuality` | true | ‚úÖ |
| `verifySelfDualityReverse` | true | ‚úÖ |
| `(fromIndex 0).val` | 0x00 | ‚úÖ |
| `(fromIndex 1).val` | 0x17 | ‚úÖ |
| `(fromIndex 15).val` | 0xFF | ‚úÖ |
| `findCodewordIndex 0#8` | some 0 | ‚úÖ |
| `findCodewordIndex 0x17#8` | some 1 | ‚úÖ |
| `findCodewordIndex 0xFF#8` | some 15 | ‚úÖ |
| `findCodewordIndex 0x01#8` | none | ‚úÖ |

### Algebraic Foundation of Triality-QEC (¬ß5.5)

| Expression | Expected value | Check |
|:---|:---|:---:|
| `h84IntersectionEven` | true | ‚úÖ |
| `h84GeomProdClosed` | true | ‚úÖ |
| `h84IsSubalgebra` | true | ‚úÖ |
| `verifyTrialityQECFoundation` | true | ‚úÖ |

## 9.5 References

[1] David A. Richter, "Gosset's Figure in a Clifford Algebra", 2004
[2] J. H. Conway & N. J. A. Sloane, "Sphere Packings, Lattices and Groups",
    3rd edition, Springer, 1999
[3] P.-P. Dechant, "The E8 Geometry from a Clifford Perspective", 2016
-/

end CL8E8TQC.Foundation
</script>

  <div id="app">
    <div id="topbar">
      <div class="logo">lean<span> notebook</span></div>
      <div class="sep">¬∑</div>
      <div class="doc-title" id="doc-title">Loading‚Ä¶</div>
      <div id="view-toggle">
        <input type="radio" name="view" id="vlean" value="lean">
        <label for="vlean">lean</label>
        <input type="radio" name="view" id="vhtml" value="html" checked>
        <label for="vhtml">HTML</label>
      </div>
    </div>
    <nav id="sidebar">
      <div id="toc-label">Contents</div>
      <div id="toc"></div>
    </nav>
    <main id="notebook"></main>
    <div id="lean-raw">
      <pre id="lean-raw-pre"></pre>
    </div>
  </div>

  <script>
// ================================================================
// renderer.js ‚Äî Shared rendering logic for LeanNotebook
// Used by both the VSCode WebView (main.js) and HTML export (template.html).
// DO NOT add VSCode-specific or VanJS-specific code here.
// ================================================================

// ----------------------------------------------------------------
// Lean 4 Syntax Highlighter
// ----------------------------------------------------------------
const LR_KW = new Set([
    'def', 'abbrev', 'theorem', 'lemma', 'example', 'noncomputable',
    'private', 'protected', 'instance', 'class', 'structure', 'inductive', 'where', 'with',
    'extends', 'deriving', 'namespace', 'end', 'section', 'open', 'import', 'export',
    'universe', 'variable', 'attribute', 'notation', 'macro', 'syntax', 'elab',
    'by', 'do', 'return', 'let', 'have', 'show', 'from', 'fun', 'match', 'if', 'then', 'else',
    'for', 'while', 'mut', 'pure', 'calc', 'suffices', 'obtain', 'refine', 'exact', 'apply',
    'intro', 'intros', 'cases', 'induction', 'constructor', 'use', 'rfl', 'simp', 'ring',
    'omega', 'linarith', 'norm_num', 'decide', 'native_decide', 'trivial', 'assumption',
    'contradiction', 'aesop', 'tauto', 'field_simp', 'push_neg', 'pull_neg',
    'partial', 'unsafe', 'opaque', 'axiom'
]);
const LR_TY = new Set([
    'Nat', 'Int', 'Bool', 'String', 'Float', 'Char', 'UInt8', 'UInt16',
    'UInt32', 'UInt64', 'Int8', 'Int16', 'Int32', 'Int64', 'List', 'Array', 'Vector',
    'Option', 'Result', 'IO', 'Type', 'Prop', 'Sort', 'Unit', 'Empty', 'True', 'False',
    'Eq', 'And', 'Or', 'Not', 'Iff', 'Exists', 'Sigma', 'Subtype', 'Fin', 'BitVec'
]);
const LR_TA = new Set([
    'native_decide', 'decide', 'rfl', 'simp', 'ring', 'omega',
    'linarith', 'norm_num', 'exact', 'apply', 'intro', 'intros', 'cases', 'rcases',
    'induction', 'constructor', 'use', 'refine', 'suffices', 'obtain', 'contradiction',
    'trivial', 'assumption', 'aesop', 'tauto', 'field_simp', 'push_neg', 'pull_neg',
    'positivity', 'norm_cast', 'push_cast', 'ext', 'funext', 'congr', 'conv', 'rw',
    'rewrite', 'gcongr', 'abel'
]);

function lrEsc(s) {
    return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function lrHlLine(raw) {
    let cmt = -1, inStr = false;
    for (let i = 0; i < raw.length - 1; i++) {
        if (raw[i] === '"' && (i === 0 || raw[i - 1] !== '\\')) inStr = !inStr;
        if (!inStr && raw[i] === '-' && raw[i + 1] === '-') { cmt = i; break; }
    }
    const codePart = cmt >= 0 ? raw.slice(0, cmt) : raw;
    const tailPart = cmt >= 0 ? raw.slice(cmt) : '';
    let out = '', i = 0;
    while (i < codePart.length) {
        const ch = codePart[i];
        if (ch === '"') {
            let j = i + 1;
            while (j < codePart.length && (codePart[j] !== '"' || codePart[j - 1] === '\\')) j++;
            out += `<span class="hl-string">${lrEsc(codePart.slice(i, j + 1))}</span>`;
            i = j + 1; continue;
        }
        if (ch === '0' && i + 1 < codePart.length && (codePart[i + 1] === 'b' || codePart[i + 1] === 'x')) {
            let j = i + 2;
            while (j < codePart.length && /[0-9a-fA-F_]/.test(codePart[j])) j++;
            let sf = '';
            if (j < codePart.length && codePart[j] === '#') {
                let k = j + 1;
                while (k < codePart.length && /\d/.test(codePart[k])) k++;
                sf = lrEsc(codePart.slice(j, k)); j = k;
            }
            out += `<span class="hl-number">${lrEsc(codePart.slice(i, j))}${sf}</span>`;
            i = j; continue;
        }
        if (/\d/.test(ch) && (i === 0 || !/\w/.test(codePart[i - 1]))) {
            let j = i;
            while (j < codePart.length && /[\d_]/.test(codePart[j])) j++;
            out += `<span class="hl-number">${lrEsc(codePart.slice(i, j))}</span>`;
            i = j; continue;
        }
        if (/[a-zA-Z_]/.test(ch) || ch.charCodeAt(0) > 127) {
            let j = i + 1;
            while (j < codePart.length && (
                /[\w']/.test(codePart[j]) ||
                /[‚ÇÄ-‚Çâ]/.test(codePart[j]) ||
                codePart.charCodeAt(j) > 127
            )) j++;
            const w = codePart.slice(i, j), e = lrEsc(w);
            if (LR_KW.has(w)) out += `<span class="hl-keyword">${e}</span>`;
            else if (LR_TA.has(w)) out += `<span class="hl-tactic">${e}</span>`;
            else if (LR_TY.has(w)) out += `<span class="hl-type">${e}</span>`;
            else if (/^[A-Z]/.test(w)) out += `<span class="hl-type">${e}</span>`;
            else out += e;
            i = j; continue;
        }
        let hit = false;
        for (const op of ['^^^', '&&&', '|||', '<<<', '>>>', '<|>', ':=', '=>', '->', '<-', '::', '..']) {
            if (codePart.startsWith(op, i)) {
                out += `<span class="hl-op">${lrEsc(op)}</span>`;
                i += op.length; hit = true; break;
            }
        }
        if (hit) continue;
        out += lrEsc(ch); i++;
    }
    if (tailPart) out += `<span class="hl-comment">${lrEsc(tailPart)}</span>`;
    return out;
}

function hlLean(codeText) {
    return codeText.split('\n').map(lrHlLine).join('\n');
}

// ----------------------------------------------------------------
// Markdown + Math renderer
// Uses string-based placeholders so marked cannot strip them.
// This is the canonical implementation used by BOTH VSCode WebView
// and the HTML export. Do not duplicate this logic elsewhere.
// ----------------------------------------------------------------
function mdToHtml(content) {
    const mathBlocks = [];
    const PH_D = (i) => `LNMATH_D_${i}_END`;
    const PH_I = (i) => `LNMATH_I_${i}_END`;

    let s = content;
    // Strip leading --- line that marked would misinterpret as YAML front matter.
    // In Lean /-! blocks, --- is used as a horizontal rule / separator, not YAML.
    s = s.replace(/^\s*---\s*\n/, '\n');
    // Display math first (multi-line)
    s = s.replace(/\$\$([\s\S]*?)\$\$/g, (m, c) => {
        const i = mathBlocks.length;
        mathBlocks.push({ t: 'd', c });
        return PH_D(i);
    });
    // Inline math (single line, not crossing $)
    s = s.replace(/\$([^$\n]+?)\$/g, (m, c) => {
        const i = mathBlocks.length;
        mathBlocks.push({ t: 'i', c });
        return PH_I(i);
    });

    let html = (typeof marked !== 'undefined')
        ? marked.parse(s)
        : s.replace(/\n/g, '<br>');

    // Restore math with original delimiters.
    // IMPORTANT: use $$ and $ (not \[..\] / \(..\)) because the JS escape sequences
    // \[ and \( collapse to [ and ( in string literals, breaking MathJax recognition.
    html = html.replace(/LNMATH_D_(\d+)_END/g, (_, i) => `$$${mathBlocks[+i].c}$$`);
    html = html.replace(/LNMATH_I_(\d+)_END/g, (_, i) => `$${mathBlocks[+i].c}$`);
    return html;
}

// ----------------------------------------------------------------
// Mermaid renderer ‚Äî single shared implementation
// Call renderMermaid(source, containerEl) from both main.js and template.html.
// ----------------------------------------------------------------
// (No CDN URL constants ‚Äî all libraries loaded from local _libs/)
// ----------------------------------------------------------------

const MERMAID_THEME = {
    startOnLoad: false,
    theme: 'neutral',
    flowchart: { useMaxWidth: false },
    themeVariables: {
        background: '#ffffff',
        mainBkg: '#dbeafe',
        nodeBorder: '#93c5fd',
        lineColor: '#2563eb',
        textColor: '#1a2233',
        fontSize: '13px',
        primaryColor: '#dbeafe',
        primaryTextColor: '#1d4ed8',
        primaryBorderColor: '#93c5fd',
        edgeLabelBackground: '#f4f7fb',
    }
};

let _mermaidInitialized = false;
function ensureMermaidInit() {
    if (_mermaidInitialized) return;
    if (typeof mermaid === 'undefined') return;
    mermaid.initialize(MERMAID_THEME);
    _mermaidInitialized = true;
}

// Render a mermaid diagram into containerEl.
// Returns a Promise that resolves when done.
async function renderMermaid(source, containerEl) {
    if (typeof mermaid === 'undefined') {
        containerEl.textContent = 'Mermaid not loaded';
        return;
    }
    ensureMermaidInit();
    const id = 'mx-' + Math.random().toString(36).slice(2);
    try {
        const { svg } = await mermaid.render(id, source);
        containerEl.innerHTML = svg;
        // Remove Mermaid's inline height/max-height constraints.
        // Do NOT set width:100% ‚Äî wide diagrams (e.g. dependency graphs)
        // would be forced into the container width, compressing height
        // proportionally via viewBox aspect-ratio preservation.
        // Instead, let the SVG keep its natural dimensions and rely on
        // CSS overflow-x:auto on .block-mermaid for horizontal scrolling.
        const svgEl = containerEl.querySelector('svg');
        if (svgEl) {
            svgEl.removeAttribute('height');
            svgEl.style.removeProperty('max-height');
        }
    } catch (e) {
        containerEl.textContent = `Mermaid Error: ${e.message}`;
    }
}

// ----------------------------------------------------------------
// Graphviz (DOT) renderer ‚Äî via @viz-js/viz (Graphviz WASM)
// Single shared implementation for both WebView and HTML export.
// ----------------------------------------------------------------
let _vizInstance = null;
let _vizInstancePromise = null;

function getVizInstance() {
    if (_vizInstance) return Promise.resolve(_vizInstance);
    if (_vizInstancePromise) return _vizInstancePromise;
    _vizInstancePromise = new Promise((resolve, reject) => {
        // Viz.js may be loaded async; poll until it's available (up to 10s).
        let elapsed = 0;
        const interval = 100;
        const maxWait = 10000;
        function check() {
            if (typeof Viz !== 'undefined') {
                Viz.instance().then(viz => {
                    _vizInstance = viz;
                    resolve(viz);
                }).catch(reject);
            } else if (elapsed >= maxWait) {
                reject(new Error('Viz.js not loaded after ' + maxWait + 'ms'));
            } else {
                elapsed += interval;
                setTimeout(check, interval);
            }
        }
        check();
    });
    return _vizInstancePromise;
}

// Render a Graphviz DOT diagram into containerEl.
// Returns a Promise that resolves when done.
async function renderGraphviz(source, containerEl) {
    try {
        const viz = await getVizInstance();
        const svgEl = viz.renderSVGElement(source);
        containerEl.innerHTML = '';
        containerEl.appendChild(svgEl);
    } catch (e) {
        containerEl.textContent = `Graphviz Error: ${e.message || e}`;
    }
}

// ----------------------------------------------------------------
// MathJax: typeset a container and wrap display math.
// Call typesetMath(container) from BOTH main.js and template.html.
// This is the single shared implementation ‚Äî do not duplicate.
// ----------------------------------------------------------------
function wrapDisplayMath(container) {
    container.querySelectorAll('mjx-container[display="true"]').forEach(el => {
        if (!el.parentElement.classList.contains('mjx-display-wrap')) {
            const wrap = document.createElement('div');
            wrap.className = 'mjx-display-wrap';
            el.parentNode.insertBefore(wrap, el);
            wrap.appendChild(el);
        }
    });
}

// Typeset MathJax in container, then wrap display math.
// Returns a Promise. Safe to call even if MathJax is not loaded.
function typesetMath(container) {
    if (window.MathJax && MathJax.typesetPromise) {
        return MathJax.typesetPromise([container])
            .then(() => wrapDisplayMath(container))
            .catch(console.warn);
    }
    return Promise.resolve();
}

// The canonical MathJax configuration object.
// Used verbatim in both NotebookPanel.ts (Extension) and template.html (HTML export).
const MATHJAX_CONFIG = {
    tex: {
        inlineMath: [['$', '$']],
        displayMath: [['$$', '$$']],
        processEscapes: true
    },
    options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
        menuOptions: {
            settings: {
                enrich: false,
                collapsible: false,
                speech: false,
                braille: false,
                assistiveMml: false
            }
        }
    },
    startup: { typeset: false }
};

// ----------------------------------------------------------------
// Lean comment parser (port of leanCommentParser.ts)
// ----------------------------------------------------------------
function trimEmptyLines(code) {
    const lines = code.split('\n');
    let s = 0;
    while (s < lines.length && lines[s].trim() === '') s++;
    let e = lines.length - 1;
    while (e >= 0 && lines[e].trim() === '') e--;
    if (s > e) return '';
    return lines.slice(s, e + 1).join('\n');
}

function dedent(str) {
    const lines = str.split('\n');
    let minIndent = Infinity;
    for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        if (line.trim().length === 0) continue;
        const m = line.match(/^\s*/);
        const indent = m ? m[0].length : 0;
        if (indent < minIndent) minIndent = indent;
    }
    if (minIndent === Infinity) minIndent = 0;
    return lines.map((line, idx) => {
        if (idx === 0) return line.trim();
        if (line.trim().length === 0) return '';
        return line.length >= minIndent ? line.slice(minIndent) : line.trim();
    }).join('\n').trim();
}

function findDocCommentEnd(text, startPos) {
    let pos = startPos;
    let inlineTickCount = null;
    let inFence = false;
    while (pos < text.length) {
        const ch = text[pos];
        if (ch === '`') {
            let run = 1;
            while (pos + run < text.length && text[pos + run] === '`') run++;
            if (inlineTickCount === null) {
                if (run >= 3) {
                    let i = pos - 1;
                    while (i >= 0 && text[i] !== '\n') i--;
                    const prefix = text.slice(i + 1, pos);
                    if (/^\s*$/.test(prefix)) { inFence = !inFence; pos += run; continue; }
                }
                if (!inFence) { inlineTickCount = run; pos += run; continue; }
            } else {
                if (run === inlineTickCount) { inlineTickCount = null; pos += run; continue; }
            }
            pos += run; continue;
        }
        const next = (pos + 1 < text.length) ? text[pos + 1] : '';
        if (!inFence && inlineTickCount === null && ch === '-' && next === '/') return pos;
        pos += 1;
    }
    return -1;
}

function splitLeanDocComments(text) {
    const blocks = [];
    let pos = 0, last = 0;

    function pushCode(code) {
        const lines = code.split('\n');
        let s = 0;
        while (s < lines.length && lines[s].trim() === '') s++;
        const rawStartLine = text.slice(0, last).split('\n').length - 1;
        const startLine = rawStartLine + s;
        const trimmedCode = trimEmptyLines(code);
        const trimmedLineCount = trimmedCode.split('\n').length;
        const endLine = startLine + (trimmedLineCount > 0 ? trimmedLineCount - 1 : 0);
        blocks.push({ type: 'code', source: trimmedCode, range: { startLine, endLine } });
    }

    function pushComment(kind, content, startOffset) {
        const dedentedContent = dedent(content);
        const startLine = text.slice(0, startOffset).split('\n').length - 1;
        const endLine = startLine + (content.split('\n').length - 1);
        blocks.push({ type: kind, content: dedentedContent, range: { startLine, endLine } });
    }

    while (pos < text.length) {
        const nextModule = text.indexOf('/-!', pos);
        const nextDoc = text.indexOf('/--', pos);
        let start = -1, kind = null;
        if (nextModule !== -1 && (nextDoc === -1 || nextModule < nextDoc)) { start = nextModule; kind = 'module-doc'; }
        else if (nextDoc !== -1) { start = nextDoc; kind = 'doc-comment'; }
        if (start === -1) break;
        if (start > last) pushCode(text.slice(last, start));
        const contentStart = start + 3;
        const end = findDocCommentEnd(text, contentStart);
        if (end === -1) { pushCode(text.slice(start)); last = text.length; break; }
        pushComment(kind, text.slice(contentStart, end), start);
        pos = end + 2; last = pos;
    }
    if (last < text.length) pushCode(text.slice(last));

    return blocks.filter(b => {
        if (b.type === 'code') return b.source.trim().length > 0;
        if (b.type === 'mermaid') return b.source.trim().length > 0;
        if (b.type === 'graphviz') return b.source.trim().length > 0;
        return b.content.trim().length > 0;
    });
}

function splitDiagramBlocks(content) {
    const result = [];
    // Note: backticks written as \x60 to avoid breaking HTML script-tag embedding
    const TICK3 = '\x60\x60\x60';
    const re = new RegExp('^' + TICK3 + '(mermaid|graphviz|dot)\\s*\\n([\\s\\S]*?)^' + TICK3 + '\\s*$', 'gm');
    let lastIndex = 0, match;
    while ((match = re.exec(content)) !== null) {
        const textContent = content.substring(lastIndex, match.index);
        if (textContent.trim().length > 0) result.push({ type: 'text', content: textContent.trim() });
        const lang = match[1]; // 'mermaid', 'graphviz', or 'dot'
        const src = match[2];
        if (src.trim().length > 0) {
            const blockType = lang === 'mermaid' ? 'mermaid' : 'graphviz';
            result.push({ type: blockType, source: trimEmptyLines(src) });
        }
        lastIndex = re.lastIndex;
    }
    if (lastIndex < content.length) {
        const remaining = content.substring(lastIndex);
        if (remaining.trim().length > 0) result.push({ type: 'text', content: remaining.trim() });
    }
    if (result.length === 0 && content.trim().length > 0)
        result.push({ type: 'text', content: content.trim() });
    return result;
}

function expandCommentBlock(block) {
    if (block.type !== 'module-doc' && block.type !== 'doc-comment') return [block];
    const subBlocks = splitDiagramBlocks(block.content);
    if (subBlocks.length === 1 && subBlocks[0].type === 'text') return [block];
    return subBlocks.map(sub =>
        sub.type === 'text'
            ? { type: block.type, content: sub.content, range: block.range }
            : { type: sub.type, source: sub.source, range: block.range }
    );
}

function parseLean(text) {
    return splitLeanDocComments(text).flatMap(b => expandCommentBlock(b));
}

  </script>
  <script>
      /* ================================================================
         Rendering and Boot ‚Äî template.html specific UI logic
         All shared logic (hlLean, mdToHtml, parseLean etc.) lives in
         renderer.js which is inlined above by htmlExporter.ts at export time.
         ================================================================ */
      async function render(blocks) {
        const nb = document.getElementById('notebook');
        nb.innerHTML = '';

        for (const b of blocks) {
          if (b.type === 'module-doc' || b.type === 'doc-comment') {
            const cls = b.type === 'module-doc' ? 'block-module-doc' : 'block-doc-comment';
            const el = document.createElement('div');
            el.className = cls;
            el.innerHTML = mdToHtml(b.content);
            // Apply Lean syntax highlighting to ```lean code fences inside markdown
            el.querySelectorAll('pre code').forEach(code => {
              const isLean = code.classList.contains('language-lean') ||
                code.classList.contains('language-lean4');
              if (isLean) {
                code.innerHTML = hlLean(code.textContent || '');
              }
            });
            nb.appendChild(el);
          } else if (b.type === 'code') {
            const el = document.createElement('div');
            el.className = 'block-code';
            el.innerHTML = `<div class="block-code-header">lean4</div><pre class="lean-source">${hlLean(b.source)}</pre>`;
            nb.appendChild(el);
          } else if (b.type === 'mermaid') {
            const wrap = document.createElement('div');
            wrap.className = 'block-mermaid';
            nb.appendChild(wrap);
            await renderMermaid(b.source, wrap);
          } else if (b.type === 'graphviz') {
            const wrap = document.createElement('div');
            wrap.className = 'block-graphviz';
            nb.appendChild(wrap);
            await renderGraphviz(b.source, wrap);
          }
        }

        // TOC
        let tocHtml = '', hi = 0;
        nb.querySelectorAll('h1,h2,h3').forEach(h => {
          const id = 'h' + hi++; h.id = id;
          tocHtml += `<a href="#${id}" class="${h.tagName.toLowerCase()}">${h.textContent}</a>\n`;
        });
        document.getElementById('toc').innerHTML = tocHtml;

        const h1 = nb.querySelector('h1');
        if (h1) {
          document.getElementById('doc-title').textContent = h1.textContent;
          document.title = h1.textContent + ' ‚Äî Lean Notebook';
        }

        // Use shared typesetMath() from renderer.js ‚Äî MathJax
        typesetMath(nb);
      }

    /* ================================================================
       Boot
       ================================================================ */
    function boot() {
      if (typeof marked === 'undefined') { setTimeout(boot, 100); return; }
      marked.use({ gfm: true, breaks: true });
      const el = document.getElementById('lean-source');
      if (!el) return;

      const rawPre = document.getElementById('lean-raw-pre');
      rawPre.innerHTML = hlLean(el.textContent);

      const blocks = parseLean(el.textContent);
      render(blocks);

      const nb = document.getElementById('notebook');
      const leanRaw = document.getElementById('lean-raw');
      const appEl = document.getElementById('app');
      document.querySelectorAll('input[name="view"]').forEach(radio => {
        radio.addEventListener('change', () => {
          if (radio.value === 'lean') {
            nb.style.display = 'none';
            leanRaw.style.display = 'block';
            appEl.classList.add('lean-mode');
          } else {
            nb.style.display = '';
            leanRaw.style.display = 'none';
            appEl.classList.remove('lean-mode');
          }
        });
      });
    }
    window.addEventListener('load', boot);
  </script>
</body>

</html>