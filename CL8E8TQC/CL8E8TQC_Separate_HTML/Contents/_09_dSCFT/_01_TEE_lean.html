<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lean Notebook Viewer</title>
  <script>
    // MathJax config â€” from MATHJAX_CONFIG in renderer.js (single source of truth).
    MathJax = {"tex":{"inlineMath":[["$","$"]],"displayMath":[["$$","$$"]],"processEscapes":true},"options":{"skipHtmlTags":["script","noscript","style","textarea","pre","code"],"menuOptions":{"settings":{"enrich":false,"collapsible":false,"speech":false,"braille":false,"assistiveMml":false}}},"startup":{"typeset":false}};
  </script>
  <script async src="../../_libs/tex-svg.js"></script>
  <script src="../../_libs/marked.min.js"></script>
  <script src="../../_libs/mermaid.min.js"></script>
  <script src="../../_libs/viz-standalone.js" async></script>
  <style>
    /* Injected from style.css by htmlExporter.ts â€” do NOT edit here. Edit style.css instead. */
    /* style.css â€” LeanNotebook VSCode Extension
   Identical CSS for both the static HTML viewer and the Extension WebView.
   Overrides VSCode user themes to prioritize the Lean brand.
*/

@import url('https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,wght@0,400;0,600;1,400&family=Fira+Code:wght@400;500&family=Inter:wght@300;400;500;600&display=swap');

:root {
  /* Lean brand: white + blue */
  --bg: #f4f7fb;
  --surface: #ffffff;
  --surface-alt: #eef2f8;
  --border: #d0daea;
  --border-soft: #e4eaf4;
  --text: #1a2233;
  --text-muted: #4a5a78;
  --text-dim: #8a9ab8;
  /* Lean blue palette */
  --blue: #2563eb;
  --blue-light: #3b82f6;
  --blue-pale: #dbeafe;
  --blue-dim: #93c5fd;
  --blue-dark: #1d4ed8;
  /* syntax */
  --hl-keyword: #1d4ed8;
  --hl-tactic: #7c3aed;
  --hl-type: #0369a1;
  --hl-string: #15803d;
  --hl-number: #b45309;
  --hl-comment: #94a3b8;
  --hl-op: #475569;
  /* code bg */
  --code-bg: #f0f4ff;
  --radius: 7px;
  --font-prose: 'Source Serif 4', Georgia, serif;
  --font-code: 'Fira Code', 'Courier New', monospace;
  --font-ui: 'Inter', system-ui, sans-serif;
  --shadow-sm: 0 1px 3px rgba(37, 99, 235, .08), 0 1px 2px rgba(0, 0, 0, .04);
  --shadow-md: 0 4px 12px rgba(37, 99, 235, .10), 0 1px 4px rgba(0, 0, 0, .05);
}

*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html {
  scroll-behavior: smooth;
  width: 100%;
  height: 100%;
}

body {
  background: var(--bg);
  color: var(--text);
  font-family: var(--font-ui);
  font-size: 16px;
  line-height: 1.6;
  min-height: 100vh;
  width: 100%;
}

/* ================================================================
   Overall Layout: Sidebar + Main Content
   Extension WebView: #layout
   HTML Export: #app (topbar + sidebar + notebook)
   ================================================================ */

/* --- Common root grid (#app) --- */
#app {
  display: grid;
  grid-template-columns: 260px 1fr;
  grid-template-rows: auto 1fr;
  min-height: 100vh;
}

#topbar {
  grid-column: 1 / -1;
  background: var(--surface);
  border-bottom: 1px solid var(--border);
  padding: 0 28px;
  height: 56px;
  display: flex;
  align-items: center;
  gap: 14px;
  position: sticky;
  top: 0;
  z-index: 100;
  box-shadow: var(--shadow-sm);
}

#topbar .logo {
  font-family: var(--font-code);
  font-size: 14px;
  color: var(--blue);
  font-weight: 600;
  letter-spacing: .02em;
  white-space: nowrap;
}

#topbar .logo span {
  color: var(--text-dim);
  font-weight: 400;
}

#topbar .doc-title {
  font-size: 14px;
  font-weight: 400;
  color: var(--text-muted);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

#topbar .sep {
  color: var(--border);
}

#view-toggle {
  margin-left: auto;
  display: flex;
  align-items: center;
  background: var(--surface-alt);
  border: 1px solid var(--border);
  border-radius: 99px;
  padding: 3px;
  gap: 2px;
}

#view-toggle label {
  font-family: var(--font-code);
  font-size: 11px;
  font-weight: 500;
  padding: 3px 12px;
  border-radius: 99px;
  cursor: pointer;
  color: var(--text-muted);
  transition: background .15s, color .15s;
  user-select: none;
  white-space: nowrap;
}

#view-toggle input[type=radio] {
  display: none;
}

#view-toggle input[type=radio]:checked+label {
  background: var(--blue);
  color: #fff;
  box-shadow: 0 1px 3px rgba(37, 99, 235, .25);
}

#notebook {
  padding: 48px 60px;
  overflow-y: auto;
  overflow-x: hidden;
}

#lean-raw {
  display: none;
  padding: 48px 60px;
  max-width: none;
  grid-column: 2;
  overflow: auto;
}

#lean-raw pre {
  background: var(--code-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 24px;
  font-family: var(--font-code);
  font-size: 13px;
  line-height: 1.7;
  tab-size: 2;
  overflow-x: auto;
  box-shadow: var(--shadow-sm);
  white-space: pre;
}

#app.lean-mode {
  grid-template-columns: 0 1fr;
}

#app.lean-mode #sidebar {
  display: none;
}

#app.lean-mode #lean-raw {
  grid-column: 1 / -1;
  padding: 48px 60px;
  display: block;
}

@media(max-width:900px) {
  #app {
    grid-template-columns: 1fr;
  }

  #app #sidebar {
    display: none;
  }

  #notebook {
    padding: 28px 20px;
  }

  #lean-raw {
    grid-column: 1;
    padding: 28px 20px;
  }
}

/* ---- Sidebar ---- */
#sidebar {
  background: var(--surface);
  border-right: 1px solid var(--border);
  overflow-y: auto;
  padding: 20px 0;
  position: sticky;
  top: 0;
  height: 100vh;
}

#toc-label {
  font-size: 10px;
  font-weight: 600;
  letter-spacing: .12em;
  text-transform: uppercase;
  color: var(--text-dim);
  padding: 0 18px 10px;
}

#toc a {
  display: block;
  padding: 4px 18px;
  font-size: 12.5px;
  color: var(--text-muted);
  text-decoration: none;
  transition: color .15s, background .15s;
  line-height: 1.5;
  border-left: 2px solid transparent;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

#toc a:hover {
  color: var(--blue);
  background: var(--blue-pale);
  border-left-color: var(--blue-light);
}

#toc a.h1 {
  font-weight: 600;
  color: var(--text);
  padding-left: 18px;
  margin-top: 6px;
}

#toc a.h2 {
  padding-left: 28px;
}

#toc a.h3 {
  padding-left: 40px;
  font-size: 11.5px;
}

/* ---- Main Content ---- */
#notebook {
  min-width: 0;
  width: 100%;
}

/* ================================================================
   Prose Blocks (shared)
   ================================================================ */
.block-module-doc,
.block-doc-comment {
  font-family: var(--font-prose);
  font-size: 17px;
  line-height: 1.85;
  color: var(--text);
  margin-bottom: 10px;
}

/* --- module-doc: white card --- */
.block-module-doc {
  padding: 32px 36px;
  background: var(--surface);
  border: 1px solid var(--border-soft);
  border-radius: var(--radius);
  box-shadow: var(--shadow-sm);
}

/* --- doc-comment: left blue border --- */
.block-doc-comment {
  padding: 16px 20px;
  border-left: 3px solid var(--blue-light);
  background: var(--blue-pale);
  border-radius: 0 var(--radius) var(--radius) 0;
}

/* ================================================================
   Prose Typography (shared)
   ================================================================ */
.block-module-doc h1,
.block-doc-comment h1,
.block-doc-comment h1,
.block-doc-comment h1 {
  font-size: 1.9em;
  font-weight: 600;
  color: var(--blue-dark);
  border-bottom: 2px solid var(--blue-pale);
  padding-bottom: 10px;
  margin: 0 0 20px;
  line-height: 1.3;
}

.block-module-doc h2,
.block-doc-comment h2,
.block-doc-comment h2,
.block-doc-comment h2 {
  font-size: 1.35em;
  font-weight: 600;
  color: var(--blue);
  margin: 24px 0 14px;
  line-height: 1.4;
}

.block-module-doc h3,
.block-doc-comment h3,
.block-doc-comment h3,
.block-doc-comment h3 {
  font-size: 1.1em;
  font-weight: 600;
  color: var(--text);
  margin: 18px 0 10px;
}

.block-module-doc h4,
.block-doc-comment h4,
.block-doc-comment h4,
.block-doc-comment h4 {
  font-size: 1em;
  font-weight: 600;
  color: var(--text-muted);
  margin: 14px 0 8px;
}

.block-module-doc p,
.block-doc-comment p,
.block-doc-comment p,
.block-doc-comment p {
  margin: 0 0 12px;
}

/* Remove bottom margin from the last child to keep padding visually equal */
.block-module-doc>*:last-child,
.block-doc-comment>*:last-child,
.block-doc-comment>*:last-child,
.block-doc-comment>*:last-child {
  margin-bottom: 0;
}

/* Remove top margin from the first child to keep padding visually equal */
.block-module-doc>*:first-child,
.block-doc-comment>*:first-child,
.block-doc-comment>*:first-child,
.block-doc-comment>*:first-child {
  margin-top: 0;
}

.block-module-doc strong,
.block-doc-comment strong,
.block-doc-comment strong,
.block-doc-comment strong {
  color: var(--text);
  font-weight: 600;
}

.block-module-doc em,
.block-doc-comment em,
.block-doc-comment em,
.block-doc-comment em {
  color: var(--text-muted);
  font-style: italic;
}

.block-module-doc ul,
.block-module-doc ol,
.block-doc-comment ul,
.block-doc-comment ol,
.block-doc-comment ul,
.block-doc-comment ol,
.block-doc-comment ul,
.block-doc-comment ol {
  margin: 8px 0 14px 22px;
}

.block-module-doc li,
.block-doc-comment li,
.block-doc-comment li,
.block-doc-comment li {
  margin-bottom: 5px;
}

.block-module-doc li p,
.block-doc-comment li p,
.block-doc-comment li p,
.block-doc-comment li p {
  margin: 0;
}

/* Inline code */
.block-module-doc code,
.block-doc-comment code,
.block-doc-comment code,
.block-doc-comment code {
  font-family: var(--font-code);
  font-size: .84em;
  background: var(--surface-alt);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 1px 5px;
  color: var(--blue-dark);
}

/* Code fences */
.block-module-doc pre,
.block-doc-comment pre,
.block-doc-comment pre,
.block-doc-comment pre {
  background: var(--code-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 14px 16px;
  overflow-x: auto;
  margin: 12px 0;
  font-family: var(--font-code);
  font-size: 13px;
  line-height: 1.7;
  tab-size: 2;
}

.block-module-doc pre code,
.block-doc-comment pre code,
.block-doc-comment pre code,
.block-doc-comment pre code {
  background: none;
  border: none;
  padding: 0;
  color: var(--text);
  font-size: inherit;
}

/* Tables */
.block-module-doc table,
.block-doc-comment table,
.block-doc-comment table,
.block-doc-comment table {
  border-collapse: collapse;
  width: 100%;
  margin: 16px 0;
  font-family: var(--font-ui);
  font-size: 14px;
}

.block-module-doc th,
.block-doc-comment th,
.block-doc-comment th,
.block-doc-comment th {
  background: var(--surface-alt);
  color: var(--blue-dark);
  font-weight: 600;
  padding: 8px 14px;
  text-align: left;
  border: 1px solid var(--border);
}

.block-module-doc td,
.block-doc-comment td,
.block-doc-comment td,
.block-doc-comment td {
  padding: 7px 14px;
  border: 1px solid var(--border);
  color: var(--text);
}

.block-module-doc tr:nth-child(even) td,
.block-doc-comment tr:nth-child(even) td,
.block-doc-comment tr:nth-child(even) td,
.block-doc-comment tr:nth-child(even) td {
  background: #f0f5fd;
}

/* Blockquotes */
.block-module-doc blockquote,
.block-doc-comment blockquote,
.block-doc-comment blockquote,
.block-doc-comment blockquote {
  border-left: 3px solid var(--blue-dim);
  padding-left: 16px;
  margin: 12px 0;
  color: var(--text-muted);
  font-style: italic;
}

.block-module-doc hr,
.block-doc-comment hr,
.block-doc-comment hr,
.block-doc-comment hr {
  border: none;
  border-top: 1px solid var(--border);
  margin: 24px 0;
}

.block-module-doc a,
.block-doc-comment a,
.block-doc-comment a,
.block-doc-comment a {
  color: var(--blue);
  text-decoration: none;
}

.block-module-doc a:hover,
.block-doc-comment a:hover,
.block-doc-comment a:hover,
.block-doc-comment a:hover {
  text-decoration: underline;
}

/* ================================================================
   Code Blocks
   ================================================================ */
.block-code {
  margin-bottom: 10px;
  border-radius: var(--radius);
  overflow: hidden;
  border: 1px solid var(--border);
  box-shadow: var(--shadow-sm);
}

.block-code-header {
  background: var(--surface-alt);
  padding: 7px 16px;
  font-family: var(--font-code);
  font-size: 11px;
  color: var(--text-dim);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  gap: 8px;
}

.block-code-header::before {
  content: '';
  display: inline-block;
  width: 7px;
  height: 7px;
  border-radius: 50%;
  background: var(--blue-light);
  opacity: .7;
}

.lean-source {
  background: var(--code-bg);
  margin: 0;
  padding: 18px 20px;
  font-family: var(--font-code);
  font-size: 13.5px;
  line-height: 1.7;
  white-space: pre;
  overflow-x: auto;
  tab-size: 2;
  color: var(--text);
}

/* ================================================================
   Syntax Highlighting
   ================================================================ */
.hl-keyword {
  color: var(--hl-keyword);
  font-weight: 600;
}

.hl-tactic {
  color: var(--hl-tactic);
}

.hl-type {
  color: var(--hl-type);
}

.hl-string {
  color: var(--hl-string);
}

.hl-number {
  color: var(--hl-number);
}

.hl-comment {
  color: var(--hl-comment);
  font-style: italic;
}

.hl-op {
  color: var(--hl-op);
}

/* ================================================================
   Mermaid Blocks
   ================================================================ */
.block-mermaid {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 28px 24px;
  margin-bottom: 10px;
  overflow-x: auto;
  overflow-y: visible;
  box-shadow: var(--shadow-sm);
}

.block-mermaid svg {
  height: auto;
}

.block-mermaid .error {
  color: #c00;
  padding: 1em;
  border-radius: 4px;
  text-align: left;
}

/* ================================================================
   Graphviz (DOT) Blocks
   ================================================================ */
.block-graphviz {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 28px 24px;
  margin-bottom: 10px;
  overflow-x: auto;
  overflow-y: visible;
  box-shadow: var(--shadow-sm);
}

.block-graphviz svg {
  height: auto;
}

.block-graphviz .error {
  color: #c00;
  padding: 1em;
  border-radius: 4px;
  text-align: left;
}

/* ================================================================
   MathJax
   ================================================================ */
mjx-container {
  color: inherit !important;
}

mjx-container[display="true"] {
  display: block !important;
  overflow: visible !important;
  margin: 0 !important;
  max-width: 100%;
  font-size: 1.15em;
}

.mjx-display-wrap {
  overflow-x: auto;
  overflow-y: hidden;
  margin: 20px 0;
  padding: 4px 0;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: thin;
  scrollbar-color: var(--blue-dim) transparent;
}

.mjx-display-wrap::-webkit-scrollbar {
  height: 4px;
}

.mjx-display-wrap::-webkit-scrollbar-track {
  background: transparent;
}

.mjx-display-wrap::-webkit-scrollbar-thumb {
  background: var(--blue-dim);
  border-radius: 2px;
}

/* Heading scroll offset */
h1,
h2,
h3,
h4,
h5,
h6 {
  scroll-margin-top: 72px;
}

/* ================================================================
   Scrollbar
   ================================================================ */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-track {
  background: transparent;
}

::-webkit-scrollbar-thumb {
  background: var(--blue-dim);
  border-radius: 3px;
}

/* ================================================================
   Lean LSP Output (#eval / proof status)
   ================================================================ */
.lean-output {
  border-top: 1px solid var(--border);
  padding: 10px 10px 10px 22px;
  background: rgba(0, 0, 0, .02);
  position: relative;
}

.lean-output::before {
  content: "";
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 4px;
  background: var(--blue);
}

.output-label {
  display: block;
  font-size: .78em;
  color: var(--text-muted);
  font-weight: 600;
  margin-bottom: 4px;
  text-transform: uppercase;
}

.lean-output pre {
  margin: 0;
  font-family: var(--font-code);
  white-space: pre-wrap;
  font-size: 13px;
}
  </style>
</head>

<body>
  <script type="text/x-lean-source" id="lean-source">import CL8E8TQC._09_dSCFT._00_CosmologicalConstant

-- Structural constants inlined (values established in _04_CoxeterAnalysis/_03_OrbitAnalysis.lean)
-- Duplicated to break dependency chain on heavy build of _01_CoxeterSystem (~170s)
namespace CL8E8TQC.dSCFT.TEE.OrbitConstants
  def jonesIndex   : Nat := 2
  def coxeterH     : Nat := 30
  def quantumDimSq : Nat := 16
  theorem fourGN_eq_120 : jonesIndex ^ 2 * coxeterH = 120 := by native_decide
  theorem gamma_numer   : jonesIndex ^ 2 = 4             := by native_decide
  theorem gamma_denom   : quantumDimSq = 16              := by native_decide
  theorem frontOnlyCount : 24 = 24 := rfl
  theorem backOnlyCount  : 24 = 24 := rfl
end CL8E8TQC.dSCFT.TEE.OrbitConstants

namespace CL8E8TQC.dSCFT.TEE

open CL8E8TQC.dSCFT.TEE.OrbitConstants (jonesIndex coxeterH quantumDimSq
  fourGN_eq_120 gamma_numer gamma_denom frontOnlyCount backOnlyCount)

/-!
# Entanglement Entropy on the E8 Lattice

**This module**: `_09_dSCFT/_01_TEE.lean`

**Previous**: `_09_dSCFT/_00_CosmologicalConstant.lean`
**Next**: `_09_dSCFT/_02_dSEmergence.lean`


## Abstract

The E8 lattice is a discrete system with topological order. Under the trinity isomorphism $\text{H}(8,4) \cong \text{Cl}(8) \cong \Gamma_{E8}$, the H(8,4) code forms a topologically protected code space (`_01_TQC` Â§0), and the Jones index $[\mathcal{M}:\mathcal{N}] = 2$ specifies topological order preparable by finite-depth circuits.

The entanglement entropy of this discrete system takes the form of **topological entanglement entropy (TEE)** established by Kitaev-Preskill (2006) and Levin-Wen (2006):

$$S(A) = \alpha|\partial A| - \gamma$$

In this E8 theory, all constituents are algebraically determined, and strong subadditivity has a completed formal proof via `native_decide` (Â§3). The continuous-spacetime Ryu-Takayanagi (RT) formula is an effective-theory approximation of this theory (Â§4).

## 1. Introduction

Formulate the entanglement entropy from E8 lattice's topological order in the Kitaev-Preskill / Levin-Wen TEE formalism, determining all constituents from E8 algebraic invariants.

## 2. Relationship to Prior Work

| Prior Work | Relationship to This Chapter |
|:---|:---|
| Kitaev-Preskill (2006) âœ… | Original source of TEE formalism $S = \alpha|\partial A| - \gamma$ |
| Levin-Wen (2006) âœ… | Independent establishment of TEE |
| Ryu-Takayanagi (2006) âœ… | Comparison with RT formula (effective approximation of this theory) |
| Jones (1983) âœ… | Mathematical foundation of $[\mathcal{M}:\mathcal{N}]=2$ |

## 3. Contributions of This Chapter

- **Formulation of E8 TEE formula**: All elements determined from E8 algebraic invariants via integer arithmetic
- **`native_decide` formal proof of strong subadditivity**: Complete verification of all 256 pairs
- **Argument that continuous theory is an effective theory**: RT formula as continuous approximation of E8 TEE

## Â§0. Epistemological Labeling

| Content | Label | Basis |
|:---|:---:|:---|
| TEE formalism $S = \alpha|\partial A| - \gamma$ | âœ… | Kitaev-Preskill (2006), Levin-Wen (2006) |
| Jones index $[\mathcal{M}:\mathcal{N}]=2$ | âœ… | Jones (1983), established in Route B |
| RT formula $S = \text{Area}/4G_N$ | âœ… | Ryu-Takayanagi (2006) |
| E8 TEE formula formulation | ðŸš€ | All elements determined from E8 invariants (original to this theory) |
| $4G_N^{E8} = 120$ | ðŸš€ | Jones indexÂ² Ã— Coxeter number is an original combination of this theory |
| `native_decide` complete verification of strong subadditivity | ðŸš€ | Constructive proof in E8 TEE is original |
| RT formula as effective approximation of E8 TEE | ðŸš€ | Positioning continuous theory as effective theory |

## 4. Chapter Structure

| Section | Title | Label | Content |
|:---|:---|:---:|:---|
| Â§1 | Why TEE | âœ… | Reason for adopting TEE instead of RT formula |
| Â§2 | E8 TEE Formula | ðŸš€ | Derivation of main formula and basis for each element |
| Â§3 | Strong Subadditivity | ðŸš€ | `native_decide` complete verification of all 256 pairs |
| Â§4 | Relationship to Continuous Physics | âœ…+ðŸš€ | Relationship between RT formula and this formula |
| Â§5 | Summary | â€” | Summary of all elements |

## Main definitions

* `fourGNE8` â€” $4G_N^{E8} = 120$ (Jones indexÂ² Ã— Coxeter number)
* `gammaNumerator` / `gammaDenominator` â€” Topological correction $4/16$
* `SSA.checkSSA` â€” Complete verification of strong subadditivity for all pairs

## Implementation notes

- **Structural constants inlined** â€” Inlined definitions to avoid heavy build (~170s) of `_01_CoxeterSystem`
- **BitVec 4 boundary representation** â€” Boundary regions represented with 4 bits, all combinations enumerated
- **Full Forbidden Float compliance** â€” All computations use only integer arithmetic

## Tags

tee, entanglement-entropy, kitaev-preskill, jones-index,
strong-subadditivity, native-decide

---
-/

/-!
# Â§1. Why "TEE" Instead of "RT Formula" âœ… [ESTABLISHED]

The standard form of the Ryu-Takayanagi (RT) formula (2006) is:

$$S_{EE}(A) = \frac{\text{Area}(\gamma_A)}{4G_N}$$

This requires **continuous area** (area of a $d-1$-dimensional hypersurface). The E8 lattice is a discrete system, and continuous area cannot be defined.

On the other hand, the **topological entanglement entropy (TEE)** independently established by Kitaev-Preskill (2006) and Levin-Wen (2006) is:

$$S_{EE}(A) = \alpha |\partial A| - \gamma + O(e^{-\xi/|\partial A|})$$

where:
- $\alpha |\partial A|$: Area law term (proportional to boundary size)
- $\gamma = \log \mathcal{D}$: Topological correction ($\mathcal{D}$ = total quantum dimension)
- $\xi$: Correlation length

TEE does not require continuous spacetime. It can be defined for discrete systems with topological order.

**Logical containment**:
$$\text{TEE (discrete, general)} \supset \text{RT (continuous, AdS special case)}$$

That E8 has topological order as a discrete system is established by the H(8,4) code forming a topologically protected code space (`_01_TQC` Â§0).
-/

/-!
## 1.1 Boundary/Bulk Structure Review

Established in `_06_E8Branching/_02_RouteB_Space.lean` (Route B):

$$\mathcal{N} \subset \mathcal{M}, \quad [\mathcal{M}:\mathcal{N}] = 2$$

- **Bulk** $\mathcal{M}$: $SO(16)_1$ WZW model ($c=8$)
- **Boundary** $\mathcal{N}$: $SO(8)_1$ WZW model ($c=4$)

Established in `_04_CoxeterAnalysis/_03_OrbitAnalysis.lean`:
- Boundary = front 4 coordinates (frontOnly roots: 24)
- Bulk = all 8 coordinates (entire E8 lattice)
- Maximum boundary-connected orbit = orbit 2 (frontOnly=10, D8visit=22)
- Boundary-disconnected orbit = orbit 6 (frontOnly=0, backOnly=0)

The "area" term in TEE is measured by boundary connection strength (D8visit count).
-/

/-!
# Â§2. Formulation of E8 TEE Formula ðŸš€ [NOVEL]

$$\boxed{S_{E8}(A) = \frac{\min_{j \in \text{conn}(A)} \text{D8visit}(j)}{4G_N^{E8}} - \frac{[\mathcal{M}:\mathcal{N}]^2}{\mathcal{D}^2}}$$

Basis for each element:

| Element | Value | Basis |
|:---|:---:|:---|
| $4G_N^{E8}$ | $120 = [\mathcal{M}:\mathcal{N}]^2 \times h$ | Jones indexÂ² Ã— Coxeter number |
| Topological correction (numerator) | $[\mathcal{M}:\mathcal{N}]^2 = 4$ | Square of Jones index |
| Topological correction (denominator) | $\mathcal{D}^2 = 16$ | 16 codewords of H(8,4) |
| $\text{conn}(A)$ | Set of Coxeter orbits connected to $A$ | Boundary/bulk classification from Â§1.1 |

$\text{D8visit}(j)$ is the number of D8-type steps in the 30-step orbit $j$.

$S(\emptyset) = 0/120 - 4/16 = -\gamma$: Consistent with vacuum entropy in the original Kitaev-Preskill/Levin-Wen papers (in systems with topological order, $S(\emptyset) < 0$ is legitimate behavior).

**All elements are described in integer arithmetic**: Fully compliant with the Forbidden Float principle.
-/

-- 4G_N^{E8} = 120 (derived from constituents)
def fourGNE8 : Nat := jonesIndex ^ 2 * coxeterH

-- Topological correction numerator (integer)
def gammaNumerator : Nat := jonesIndex ^ 2

-- Topological correction denominator (integer)
def gammaDenominator : Nat := quantumDimSq

-- Formal confirmation of 4G_N^{E8} = 120
theorem fourGNE8_eq_120 : fourGNE8 = 120 := fourGN_eq_120

-- Formal confirmation of topological correction = 4/16 = 1/4
theorem gamma_is_4over16 : gammaNumerator = 4 âˆ§ gammaDenominator = 16 :=
  âŸ¨gamma_numer, gamma_denomâŸ©

/-!
## 2.1 Entropy Candidate Values for Each Orbit

D8visit count divided by $4G_N^{E8} = 120$ gives the area term candidate:

| Orbit | D8visit | Area Term (numerator/120) | Topological Correction (4/16) | Candidate $S$ |
|:---:|:---:|:---:|:---:|:---:|
| 0 | 10 | 1/12 | 1/4 | âˆ’1/6 |
| 1 | 14 | 7/60 | 1/4 | âˆ’8/60 |
| 2 | 22 | 11/60 | 1/4 | âˆ’4/60 |
| 3 | 10 | 1/12 | 1/4 | âˆ’1/6 |
| 4 | 14 | 7/60 | 1/4 | âˆ’8/60 |
| 5 | 14 | 7/60 | 1/4 | âˆ’8/60 |
| 6 | 10 | 1/12 | 1/4 | âˆ’1/6 |
| 7 | 18 | 3/20 | 1/4 | âˆ’2/20 |

All values are negative. In standard TEE, $S(A) - \alpha|\partial A| = -\gamma < 0$ represents the topological correction. $S(\emptyset) = -\gamma$ is a legitimate value as discussed in Â§2.
-/

/-!
# Â§3. Proof of Strong Subadditivity ðŸš€ [NOVEL]

$$S(A) + S(B) \geq S(A \cup B) + S(A \cap B)$$

Boundary region $A \subseteq \{0,1,2,3\}$ is represented as `BitVec 4`, and all $16 \times 16 = 256$ pairs are completely verified via `native_decide`.

Basis for validity: From additivity of the `conn` map $\text{conn}(A \cup B) = \text{conn}(A) \cup \text{conn}(B)$, SSA automatically follows from monotonicity of $\min$.
-/

namespace SSA

def d8visits : Array Nat := #[10, 14, 22, 10, 14, 14, 10, 18]
def frontOnlyCounts : Array Nat := #[4, 4, 10, 2, 0, 4, 0, 0]

abbrev BoundaryRegion := BitVec 4

def isEmpty (A : BoundaryRegion) : Bool := A == 0#4

def frontConnectedOrbits : Array Nat :=
  (Array.range 8).filter (fun j => frontOnlyCounts[j]! > 0)

def connOrbits (A : BoundaryRegion) : Array Nat :=
  if isEmpty A then #[] else frontConnectedOrbits

def connSet (A : BoundaryRegion) : BitVec 8 :=
  (connOrbits A).foldl (fun s j => s ||| (BitVec.ofNat 8 (1 <<< j))) 0#8

def minD8visit (A : BoundaryRegion) : Nat :=
  let orbs := connOrbits A
  if orbs.isEmpty then 0
  else orbs.foldl (fun m j => min m (d8visits[j]!)) (d8visits[orbs[0]!]!)

def checkSSA : Bool :=
  (Array.range 16).all fun a =>
  (Array.range 16).all fun b =>
    let A : BoundaryRegion := BitVec.ofNat 4 a
    let B : BoundaryRegion := BitVec.ofNat 4 b
    minD8visit A + minD8visit B â‰¥ minD8visit (A ||| B) + minD8visit (A &&& B)

/-- E8 TEE formula satisfies strong subadditivity (verified for all 256 pairs) -/
theorem ssa_holds : checkSSA = true :=
  by native_decide

def checkConnUnion : Bool :=
  (Array.range 16).all fun a =>
  (Array.range 16).all fun b =>
    let A : BoundaryRegion := BitVec.ofNat 4 a
    let B : BoundaryRegion := BitVec.ofNat 4 b
    connSet (A ||| B) == (connSet A ||| connSet B)

def checkConnIntersectionSubset : Bool :=
  (Array.range 16).all fun a =>
  (Array.range 16).all fun b =>
    let A : BoundaryRegion := BitVec.ofNat 4 a
    let B : BoundaryRegion := BitVec.ofNat 4 b
    let lhs := connSet (A &&& B)
    let rhs := connSet A &&& connSet B
    (lhs &&& rhs) == lhs

/-- conn(AâˆªB) = conn(A) âˆª conn(B) (additivity) -/
theorem conn_union_additive : checkConnUnion = true :=
  by native_decide

/-- conn(Aâˆ©B) âŠ† conn(A) âˆ© conn(B) (subadditivity) -/
theorem conn_intersection_subset : checkConnIntersectionSubset = true :=
  by native_decide

/-- Numerator of S(âˆ…) = 0 (because conn is empty) â†’ S(âˆ…) = -Î³ -/
theorem minD8visit_empty : minD8visit 0#4 = 0 :=
  by native_decide

end SSA

/-!
# Â§4. Continuous Physics Is an Effective Theory of This Theory âœ… + ðŸš€

As $\text{H}(8,4) \cong \text{Cl}(8) \cong \Gamma_{E8}$ shows, the universe is fundamentally **discrete**. Continuous spacetime, continuous fields, and continuous geometry emerge as **effective theories** at scales much larger than the Planck scale $\ell_P$.

| Continuous Theory | Position in E8 Theory | Corresponding E8 Structure |
|:---|:---|:---|
| Ryu-Takayanagi formula $S = \text{Area}/4G_N$ | Continuous approximation of E8 TEE | D8visit$/4G_N^{E8}$ |
| General relativity | Continuous approximation of Coxeter orbit dynamics | $h=30$ â†’ time emergence (Route A) |
| Quantum field theory | Continuous approximation of E8 cellular automaton | `_10_E8CA` |
| Continuous AdS/CFT correspondence | Continuous approximation of discrete Jones index inclusion | $[\mathcal{M}:\mathcal{N}]=2$ |
| Standard Model gauge theory | Continuous approximation of D4â†’$G_{SM}$ branching | Route C (`_06_E8Branching` Â§3) |

Just as lattice QCD (discrete) is more fundamental than continuous QCD, E8 lattice theory is more fundamental than continuous field theory. This theory need not "approach the continuous limit." Connes' Spectral Truncation (truncating the Dirac operator spectrum at cutoff $\Lambda$ and recovering continuous manifolds as $\Lambda \to \infty$) is also unnecessary. This theory derives physical quantities directly on discrete spectral triples, requiring no discreteâ†’continuous limit operation.

**Intellectual honesty**: The only unresolved item is the discrete construction of "wormholes" on the E8 lattice. This theory's design principle (Matrix-Free) does not introduce tensor products, so the formal definition of "entanglement" is outside its scope â€” this is a design choice. ER=EPR is positioned as an effective-theory consequence of this theory (â†’ `_02_dSEmergence.lean` Â§7.9.2).
-/

/-!
# Â§5. Summary

$$\boxed{S_{E8}(A) = \frac{\min_{j \in \text{conn}(A)} \text{D8visit}(j)}{120} - \frac{4}{16}}$$

| Element | Value | Basis |
|:---|:---:|:---|
| $4G_N^{E8}$ | $120$ | $[\mathcal{M}:\mathcal{N}]^2 \times h = 4 \times 30$ |
| Topological correction (integer ratio) | $4/16$ | $[\mathcal{M}:\mathcal{N}]^2 / \mathcal{D}^2$ |
| $\gamma^{E8}$ | $2\log 2$ | Algebraically determined from Jones index |
| Strong subadditivity | âœ… Proved | Â§3 (all 256 pairs, `native_decide`) |

Ryu-Takayanagi formula $S = \text{Area}/4G_N$ is an effective-theory approximation of this formula. At observation scale $\ell \gg \ell_P$, $\text{D8visit}/120 \approx \text{Area}/4G_N$.

## References

- Ryu, S. & Takayanagi, T. (2006). *Phys. Rev. Lett.* 96, 181602.
- Kitaev, A. & Preskill, J. (2006). *Phys. Rev. Lett.* 96, 110404.
- Levin, M. & Wen, X.-G. (2006). *Phys. Rev. Lett.* 96, 110405.
- Jones, V.F.R. (1983). *Invent. Math.* 72, 1â€“25.
- Maldacena, J. & Susskind, L. (2013). *Fortschritte der Physik* 61, 781â€“811.
-/

end CL8E8TQC.dSCFT.TEE
</script>

  <div id="app">
    <div id="topbar">
      <div class="logo">lean<span> notebook</span></div>
      <div class="sep">Â·</div>
      <div class="doc-title" id="doc-title">Loadingâ€¦</div>
      <div id="view-toggle">
        <input type="radio" name="view" id="vlean" value="lean">
        <label for="vlean">lean</label>
        <input type="radio" name="view" id="vhtml" value="html" checked>
        <label for="vhtml">HTML</label>
      </div>
    </div>
    <nav id="sidebar">
      <div id="toc-label">Contents</div>
      <div id="toc"></div>
    </nav>
    <main id="notebook"></main>
    <div id="lean-raw">
      <pre id="lean-raw-pre"></pre>
    </div>
  </div>

  <script>
// ================================================================
// renderer.js â€” Shared rendering logic for LeanNotebook
// Used by both the VSCode WebView (main.js) and HTML export (template.html).
// DO NOT add VSCode-specific or VanJS-specific code here.
// ================================================================

// ----------------------------------------------------------------
// Lean 4 Syntax Highlighter
// ----------------------------------------------------------------
const LR_KW = new Set([
    'def', 'abbrev', 'theorem', 'lemma', 'example', 'noncomputable',
    'private', 'protected', 'instance', 'class', 'structure', 'inductive', 'where', 'with',
    'extends', 'deriving', 'namespace', 'end', 'section', 'open', 'import', 'export',
    'universe', 'variable', 'attribute', 'notation', 'macro', 'syntax', 'elab',
    'by', 'do', 'return', 'let', 'have', 'show', 'from', 'fun', 'match', 'if', 'then', 'else',
    'for', 'while', 'mut', 'pure', 'calc', 'suffices', 'obtain', 'refine', 'exact', 'apply',
    'intro', 'intros', 'cases', 'induction', 'constructor', 'use', 'rfl', 'simp', 'ring',
    'omega', 'linarith', 'norm_num', 'decide', 'native_decide', 'trivial', 'assumption',
    'contradiction', 'aesop', 'tauto', 'field_simp', 'push_neg', 'pull_neg',
    'partial', 'unsafe', 'opaque', 'axiom'
]);
const LR_TY = new Set([
    'Nat', 'Int', 'Bool', 'String', 'Float', 'Char', 'UInt8', 'UInt16',
    'UInt32', 'UInt64', 'Int8', 'Int16', 'Int32', 'Int64', 'List', 'Array', 'Vector',
    'Option', 'Result', 'IO', 'Type', 'Prop', 'Sort', 'Unit', 'Empty', 'True', 'False',
    'Eq', 'And', 'Or', 'Not', 'Iff', 'Exists', 'Sigma', 'Subtype', 'Fin', 'BitVec'
]);
const LR_TA = new Set([
    'native_decide', 'decide', 'rfl', 'simp', 'ring', 'omega',
    'linarith', 'norm_num', 'exact', 'apply', 'intro', 'intros', 'cases', 'rcases',
    'induction', 'constructor', 'use', 'refine', 'suffices', 'obtain', 'contradiction',
    'trivial', 'assumption', 'aesop', 'tauto', 'field_simp', 'push_neg', 'pull_neg',
    'positivity', 'norm_cast', 'push_cast', 'ext', 'funext', 'congr', 'conv', 'rw',
    'rewrite', 'gcongr', 'abel'
]);

function lrEsc(s) {
    return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function lrHlLine(raw) {
    let cmt = -1, inStr = false;
    for (let i = 0; i < raw.length - 1; i++) {
        if (raw[i] === '"' && (i === 0 || raw[i - 1] !== '\\')) inStr = !inStr;
        if (!inStr && raw[i] === '-' && raw[i + 1] === '-') { cmt = i; break; }
    }
    const codePart = cmt >= 0 ? raw.slice(0, cmt) : raw;
    const tailPart = cmt >= 0 ? raw.slice(cmt) : '';
    let out = '', i = 0;
    while (i < codePart.length) {
        const ch = codePart[i];
        if (ch === '"') {
            let j = i + 1;
            while (j < codePart.length && (codePart[j] !== '"' || codePart[j - 1] === '\\')) j++;
            out += `<span class="hl-string">${lrEsc(codePart.slice(i, j + 1))}</span>`;
            i = j + 1; continue;
        }
        if (ch === '0' && i + 1 < codePart.length && (codePart[i + 1] === 'b' || codePart[i + 1] === 'x')) {
            let j = i + 2;
            while (j < codePart.length && /[0-9a-fA-F_]/.test(codePart[j])) j++;
            let sf = '';
            if (j < codePart.length && codePart[j] === '#') {
                let k = j + 1;
                while (k < codePart.length && /\d/.test(codePart[k])) k++;
                sf = lrEsc(codePart.slice(j, k)); j = k;
            }
            out += `<span class="hl-number">${lrEsc(codePart.slice(i, j))}${sf}</span>`;
            i = j; continue;
        }
        if (/\d/.test(ch) && (i === 0 || !/\w/.test(codePart[i - 1]))) {
            let j = i;
            while (j < codePart.length && /[\d_]/.test(codePart[j])) j++;
            out += `<span class="hl-number">${lrEsc(codePart.slice(i, j))}</span>`;
            i = j; continue;
        }
        if (/[a-zA-Z_]/.test(ch) || ch.charCodeAt(0) > 127) {
            let j = i + 1;
            while (j < codePart.length && (
                /[\w']/.test(codePart[j]) ||
                /[â‚€-â‚‰]/.test(codePart[j]) ||
                codePart.charCodeAt(j) > 127
            )) j++;
            const w = codePart.slice(i, j), e = lrEsc(w);
            if (LR_KW.has(w)) out += `<span class="hl-keyword">${e}</span>`;
            else if (LR_TA.has(w)) out += `<span class="hl-tactic">${e}</span>`;
            else if (LR_TY.has(w)) out += `<span class="hl-type">${e}</span>`;
            else if (/^[A-Z]/.test(w)) out += `<span class="hl-type">${e}</span>`;
            else out += e;
            i = j; continue;
        }
        let hit = false;
        for (const op of ['^^^', '&&&', '|||', '<<<', '>>>', '<|>', ':=', '=>', '->', '<-', '::', '..']) {
            if (codePart.startsWith(op, i)) {
                out += `<span class="hl-op">${lrEsc(op)}</span>`;
                i += op.length; hit = true; break;
            }
        }
        if (hit) continue;
        out += lrEsc(ch); i++;
    }
    if (tailPart) out += `<span class="hl-comment">${lrEsc(tailPart)}</span>`;
    return out;
}

function hlLean(codeText) {
    return codeText.split('\n').map(lrHlLine).join('\n');
}

// ----------------------------------------------------------------
// Markdown + Math renderer
// Uses string-based placeholders so marked cannot strip them.
// This is the canonical implementation used by BOTH VSCode WebView
// and the HTML export. Do not duplicate this logic elsewhere.
// ----------------------------------------------------------------
function mdToHtml(content) {
    const mathBlocks = [];
    const PH_D = (i) => `LNMATH_D_${i}_END`;
    const PH_I = (i) => `LNMATH_I_${i}_END`;

    let s = content;
    // Strip leading --- line that marked would misinterpret as YAML front matter.
    // In Lean /-! blocks, --- is used as a horizontal rule / separator, not YAML.
    s = s.replace(/^\s*---\s*\n/, '\n');
    // Display math first (multi-line)
    s = s.replace(/\$\$([\s\S]*?)\$\$/g, (m, c) => {
        const i = mathBlocks.length;
        mathBlocks.push({ t: 'd', c });
        return PH_D(i);
    });
    // Inline math (single line, not crossing $)
    s = s.replace(/\$([^$\n]+?)\$/g, (m, c) => {
        const i = mathBlocks.length;
        mathBlocks.push({ t: 'i', c });
        return PH_I(i);
    });

    let html = (typeof marked !== 'undefined')
        ? marked.parse(s)
        : s.replace(/\n/g, '<br>');

    // Restore math with original delimiters.
    // IMPORTANT: use $$ and $ (not \[..\] / \(..\)) because the JS escape sequences
    // \[ and \( collapse to [ and ( in string literals, breaking MathJax recognition.
    html = html.replace(/LNMATH_D_(\d+)_END/g, (_, i) => `$$${mathBlocks[+i].c}$$`);
    html = html.replace(/LNMATH_I_(\d+)_END/g, (_, i) => `$${mathBlocks[+i].c}$`);
    return html;
}

// ----------------------------------------------------------------
// Mermaid renderer â€” single shared implementation
// Call renderMermaid(source, containerEl) from both main.js and template.html.
// ----------------------------------------------------------------
// (No CDN URL constants â€” all libraries loaded from local _libs/)
// ----------------------------------------------------------------

const MERMAID_THEME = {
    startOnLoad: false,
    theme: 'neutral',
    flowchart: { useMaxWidth: false },
    themeVariables: {
        background: '#ffffff',
        mainBkg: '#dbeafe',
        nodeBorder: '#93c5fd',
        lineColor: '#2563eb',
        textColor: '#1a2233',
        fontSize: '13px',
        primaryColor: '#dbeafe',
        primaryTextColor: '#1d4ed8',
        primaryBorderColor: '#93c5fd',
        edgeLabelBackground: '#f4f7fb',
    }
};

let _mermaidInitialized = false;
function ensureMermaidInit() {
    if (_mermaidInitialized) return;
    if (typeof mermaid === 'undefined') return;
    mermaid.initialize(MERMAID_THEME);
    _mermaidInitialized = true;
}

// Render a mermaid diagram into containerEl.
// Returns a Promise that resolves when done.
async function renderMermaid(source, containerEl) {
    if (typeof mermaid === 'undefined') {
        containerEl.textContent = 'Mermaid not loaded';
        return;
    }
    ensureMermaidInit();
    const id = 'mx-' + Math.random().toString(36).slice(2);
    try {
        const { svg } = await mermaid.render(id, source);
        containerEl.innerHTML = svg;
        // Remove Mermaid's inline height/max-height constraints.
        // Do NOT set width:100% â€” wide diagrams (e.g. dependency graphs)
        // would be forced into the container width, compressing height
        // proportionally via viewBox aspect-ratio preservation.
        // Instead, let the SVG keep its natural dimensions and rely on
        // CSS overflow-x:auto on .block-mermaid for horizontal scrolling.
        const svgEl = containerEl.querySelector('svg');
        if (svgEl) {
            svgEl.removeAttribute('height');
            svgEl.style.removeProperty('max-height');
        }
    } catch (e) {
        containerEl.textContent = `Mermaid Error: ${e.message}`;
    }
}

// ----------------------------------------------------------------
// Graphviz (DOT) renderer â€” via @viz-js/viz (Graphviz WASM)
// Single shared implementation for both WebView and HTML export.
// ----------------------------------------------------------------
let _vizInstance = null;
let _vizInstancePromise = null;

function getVizInstance() {
    if (_vizInstance) return Promise.resolve(_vizInstance);
    if (_vizInstancePromise) return _vizInstancePromise;
    _vizInstancePromise = new Promise((resolve, reject) => {
        // Viz.js may be loaded async; poll until it's available (up to 10s).
        let elapsed = 0;
        const interval = 100;
        const maxWait = 10000;
        function check() {
            if (typeof Viz !== 'undefined') {
                Viz.instance().then(viz => {
                    _vizInstance = viz;
                    resolve(viz);
                }).catch(reject);
            } else if (elapsed >= maxWait) {
                reject(new Error('Viz.js not loaded after ' + maxWait + 'ms'));
            } else {
                elapsed += interval;
                setTimeout(check, interval);
            }
        }
        check();
    });
    return _vizInstancePromise;
}

// Render a Graphviz DOT diagram into containerEl.
// Returns a Promise that resolves when done.
async function renderGraphviz(source, containerEl) {
    try {
        const viz = await getVizInstance();
        const svgEl = viz.renderSVGElement(source);
        containerEl.innerHTML = '';
        containerEl.appendChild(svgEl);
    } catch (e) {
        containerEl.textContent = `Graphviz Error: ${e.message || e}`;
    }
}

// ----------------------------------------------------------------
// MathJax: typeset a container and wrap display math.
// Call typesetMath(container) from BOTH main.js and template.html.
// This is the single shared implementation â€” do not duplicate.
// ----------------------------------------------------------------
function wrapDisplayMath(container) {
    container.querySelectorAll('mjx-container[display="true"]').forEach(el => {
        if (!el.parentElement.classList.contains('mjx-display-wrap')) {
            const wrap = document.createElement('div');
            wrap.className = 'mjx-display-wrap';
            el.parentNode.insertBefore(wrap, el);
            wrap.appendChild(el);
        }
    });
}

// Typeset MathJax in container, then wrap display math.
// Returns a Promise. Safe to call even if MathJax is not loaded.
function typesetMath(container) {
    if (window.MathJax && MathJax.typesetPromise) {
        return MathJax.typesetPromise([container])
            .then(() => wrapDisplayMath(container))
            .catch(console.warn);
    }
    return Promise.resolve();
}

// The canonical MathJax configuration object.
// Used verbatim in both NotebookPanel.ts (Extension) and template.html (HTML export).
const MATHJAX_CONFIG = {
    tex: {
        inlineMath: [['$', '$']],
        displayMath: [['$$', '$$']],
        processEscapes: true
    },
    options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
        menuOptions: {
            settings: {
                enrich: false,
                collapsible: false,
                speech: false,
                braille: false,
                assistiveMml: false
            }
        }
    },
    startup: { typeset: false }
};

// ----------------------------------------------------------------
// Lean comment parser (port of leanCommentParser.ts)
// ----------------------------------------------------------------
function trimEmptyLines(code) {
    const lines = code.split('\n');
    let s = 0;
    while (s < lines.length && lines[s].trim() === '') s++;
    let e = lines.length - 1;
    while (e >= 0 && lines[e].trim() === '') e--;
    if (s > e) return '';
    return lines.slice(s, e + 1).join('\n');
}

function dedent(str) {
    const lines = str.split('\n');
    let minIndent = Infinity;
    for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        if (line.trim().length === 0) continue;
        const m = line.match(/^\s*/);
        const indent = m ? m[0].length : 0;
        if (indent < minIndent) minIndent = indent;
    }
    if (minIndent === Infinity) minIndent = 0;
    return lines.map((line, idx) => {
        if (idx === 0) return line.trim();
        if (line.trim().length === 0) return '';
        return line.length >= minIndent ? line.slice(minIndent) : line.trim();
    }).join('\n').trim();
}

function findDocCommentEnd(text, startPos) {
    let pos = startPos;
    let inlineTickCount = null;
    let inFence = false;
    while (pos < text.length) {
        const ch = text[pos];
        if (ch === '`') {
            let run = 1;
            while (pos + run < text.length && text[pos + run] === '`') run++;
            if (inlineTickCount === null) {
                if (run >= 3) {
                    let i = pos - 1;
                    while (i >= 0 && text[i] !== '\n') i--;
                    const prefix = text.slice(i + 1, pos);
                    if (/^\s*$/.test(prefix)) { inFence = !inFence; pos += run; continue; }
                }
                if (!inFence) { inlineTickCount = run; pos += run; continue; }
            } else {
                if (run === inlineTickCount) { inlineTickCount = null; pos += run; continue; }
            }
            pos += run; continue;
        }
        const next = (pos + 1 < text.length) ? text[pos + 1] : '';
        if (!inFence && inlineTickCount === null && ch === '-' && next === '/') return pos;
        pos += 1;
    }
    return -1;
}

function splitLeanDocComments(text) {
    const blocks = [];
    let pos = 0, last = 0;

    function pushCode(code) {
        const lines = code.split('\n');
        let s = 0;
        while (s < lines.length && lines[s].trim() === '') s++;
        const rawStartLine = text.slice(0, last).split('\n').length - 1;
        const startLine = rawStartLine + s;
        const trimmedCode = trimEmptyLines(code);
        const trimmedLineCount = trimmedCode.split('\n').length;
        const endLine = startLine + (trimmedLineCount > 0 ? trimmedLineCount - 1 : 0);
        blocks.push({ type: 'code', source: trimmedCode, range: { startLine, endLine } });
    }

    function pushComment(kind, content, startOffset) {
        const dedentedContent = dedent(content);
        const startLine = text.slice(0, startOffset).split('\n').length - 1;
        const endLine = startLine + (content.split('\n').length - 1);
        blocks.push({ type: kind, content: dedentedContent, range: { startLine, endLine } });
    }

    while (pos < text.length) {
        const nextModule = text.indexOf('/-!', pos);
        const nextDoc = text.indexOf('/--', pos);
        let start = -1, kind = null;
        if (nextModule !== -1 && (nextDoc === -1 || nextModule < nextDoc)) { start = nextModule; kind = 'module-doc'; }
        else if (nextDoc !== -1) { start = nextDoc; kind = 'doc-comment'; }
        if (start === -1) break;
        if (start > last) pushCode(text.slice(last, start));
        const contentStart = start + 3;
        const end = findDocCommentEnd(text, contentStart);
        if (end === -1) { pushCode(text.slice(start)); last = text.length; break; }
        pushComment(kind, text.slice(contentStart, end), start);
        pos = end + 2; last = pos;
    }
    if (last < text.length) pushCode(text.slice(last));

    return blocks.filter(b => {
        if (b.type === 'code') return b.source.trim().length > 0;
        if (b.type === 'mermaid') return b.source.trim().length > 0;
        if (b.type === 'graphviz') return b.source.trim().length > 0;
        return b.content.trim().length > 0;
    });
}

function splitDiagramBlocks(content) {
    const result = [];
    // Note: backticks written as \x60 to avoid breaking HTML script-tag embedding
    const TICK3 = '\x60\x60\x60';
    const re = new RegExp('^' + TICK3 + '(mermaid|graphviz|dot)\\s*\\n([\\s\\S]*?)^' + TICK3 + '\\s*$', 'gm');
    let lastIndex = 0, match;
    while ((match = re.exec(content)) !== null) {
        const textContent = content.substring(lastIndex, match.index);
        if (textContent.trim().length > 0) result.push({ type: 'text', content: textContent.trim() });
        const lang = match[1]; // 'mermaid', 'graphviz', or 'dot'
        const src = match[2];
        if (src.trim().length > 0) {
            const blockType = lang === 'mermaid' ? 'mermaid' : 'graphviz';
            result.push({ type: blockType, source: trimEmptyLines(src) });
        }
        lastIndex = re.lastIndex;
    }
    if (lastIndex < content.length) {
        const remaining = content.substring(lastIndex);
        if (remaining.trim().length > 0) result.push({ type: 'text', content: remaining.trim() });
    }
    if (result.length === 0 && content.trim().length > 0)
        result.push({ type: 'text', content: content.trim() });
    return result;
}

function expandCommentBlock(block) {
    if (block.type !== 'module-doc' && block.type !== 'doc-comment') return [block];
    const subBlocks = splitDiagramBlocks(block.content);
    if (subBlocks.length === 1 && subBlocks[0].type === 'text') return [block];
    return subBlocks.map(sub =>
        sub.type === 'text'
            ? { type: block.type, content: sub.content, range: block.range }
            : { type: sub.type, source: sub.source, range: block.range }
    );
}

function parseLean(text) {
    return splitLeanDocComments(text).flatMap(b => expandCommentBlock(b));
}

  </script>
  <script>
      /* ================================================================
         Rendering and Boot â€” template.html specific UI logic
         All shared logic (hlLean, mdToHtml, parseLean etc.) lives in
         renderer.js which is inlined above by htmlExporter.ts at export time.
         ================================================================ */
      async function render(blocks) {
        const nb = document.getElementById('notebook');
        nb.innerHTML = '';

        for (const b of blocks) {
          if (b.type === 'module-doc' || b.type === 'doc-comment') {
            const cls = b.type === 'module-doc' ? 'block-module-doc' : 'block-doc-comment';
            const el = document.createElement('div');
            el.className = cls;
            el.innerHTML = mdToHtml(b.content);
            // Apply Lean syntax highlighting to ```lean code fences inside markdown
            el.querySelectorAll('pre code').forEach(code => {
              const isLean = code.classList.contains('language-lean') ||
                code.classList.contains('language-lean4');
              if (isLean) {
                code.innerHTML = hlLean(code.textContent || '');
              }
            });
            nb.appendChild(el);
          } else if (b.type === 'code') {
            const el = document.createElement('div');
            el.className = 'block-code';
            el.innerHTML = `<div class="block-code-header">lean4</div><pre class="lean-source">${hlLean(b.source)}</pre>`;
            nb.appendChild(el);
          } else if (b.type === 'mermaid') {
            const wrap = document.createElement('div');
            wrap.className = 'block-mermaid';
            nb.appendChild(wrap);
            await renderMermaid(b.source, wrap);
          } else if (b.type === 'graphviz') {
            const wrap = document.createElement('div');
            wrap.className = 'block-graphviz';
            nb.appendChild(wrap);
            await renderGraphviz(b.source, wrap);
          }
        }

        // TOC
        let tocHtml = '', hi = 0;
        nb.querySelectorAll('h1,h2,h3').forEach(h => {
          const id = 'h' + hi++; h.id = id;
          tocHtml += `<a href="#${id}" class="${h.tagName.toLowerCase()}">${h.textContent}</a>\n`;
        });
        document.getElementById('toc').innerHTML = tocHtml;

        const h1 = nb.querySelector('h1');
        if (h1) {
          document.getElementById('doc-title').textContent = h1.textContent;
          document.title = h1.textContent + ' â€” Lean Notebook';
        }

        // Use shared typesetMath() from renderer.js â€” MathJax
        typesetMath(nb);
      }

    /* ================================================================
       Boot
       ================================================================ */
    function boot() {
      if (typeof marked === 'undefined') { setTimeout(boot, 100); return; }
      marked.use({ gfm: true, breaks: true });
      const el = document.getElementById('lean-source');
      if (!el) return;

      const rawPre = document.getElementById('lean-raw-pre');
      rawPre.innerHTML = hlLean(el.textContent);

      const blocks = parseLean(el.textContent);
      render(blocks);

      const nb = document.getElementById('notebook');
      const leanRaw = document.getElementById('lean-raw');
      const appEl = document.getElementById('app');
      document.querySelectorAll('input[name="view"]').forEach(radio => {
        radio.addEventListener('change', () => {
          if (radio.value === 'lean') {
            nb.style.display = 'none';
            leanRaw.style.display = 'block';
            appEl.classList.add('lean-mode');
          } else {
            nb.style.display = '';
            leanRaw.style.display = 'none';
            appEl.classList.remove('lean-mode');
          }
        });
      });
    }
    window.addEventListener('load', boot);
  </script>
</body>

</html>